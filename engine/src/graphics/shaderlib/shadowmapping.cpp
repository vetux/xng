/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2025 Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.

 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "xng/graphics/shaderlib/shadowmapping.hpp"

#include "xng/rendergraph/shaderscript/shaderscript.hpp"

using namespace xng::ShaderScript;

namespace xng::shaderlib::shadowmapping {
    void sampleShadowPoint() {
        Function("sampleShadowPoint", {
                     {ShaderDataType::vec3(), "fragPos"},
                     {ShaderDataType::vec3(), "lightPos"},
                     {ShaderDataType::vec3(), "viewPos"},
                     {ShaderTexture(TEXTURE_CUBE_MAP_ARRAY, DEPTH), "depthMap"},
                     {ShaderDataType::Int(), "depthMapIndex"},
                     {ShaderDataType::Float(), "far_plane"}
                 },
                 ShaderDataType::Float());
        {
            ARGUMENT(vec3, fragPos)
            ARGUMENT(vec3, lightPos)
            ARGUMENT(vec3, viewPos)
            ARGUMENT(TextureSampler, depthMap)
            ARGUMENT(Int, depthMapIndex)
            ARGUMENT(Float, far_plane)

            ArrayVec3<20> gridSamplingDisk;
            gridSamplingDisk = std::vector{
                vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),
                vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
                vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0),
                vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
                vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1)
            };

            Int samples = Int(20);
            Float fSamples = Float(20.0f);

            vec3 fragToLight = fragPos - lightPos;
            fragToLight.z() *= -1;

            Float currentDepth = length(fragToLight);

            Float shadow;
            shadow = Float(0.0f);

            //TODO: Fix point shadows artifacts (Visible steps in the shadow fade)
            //TODO: Configurable shadow bias

            // The bias applied to the currentDepth in world space units.
            Float bias = Float(0.15f);

            Float viewDistance = length(viewPos - fragPos);
            Float diskRadius = (1.0 + (viewDistance / far_plane)) / far_plane;

            For(Int, i, 0, i < samples, i + 1)
                vec3 sampleDir = fragToLight + gridSamplingDisk[i] * diskRadius;
                Float closestDepth = textureSampleCubeArray(depthMap, vec4(sampleDir, depthMapIndex)).x();

                // closestDepth contains linear depth produced by the shadow mapping pass.

                // Convert depth into a world space distance by multiplying by far_plane.
                // This works because the shadow map is generated by manually writing linear depth values
                // which represent the distance of the fragment to the light in the range 0(Light Position) : Far Plane.
                closestDepth *= far_plane;

                // Compare the distance of the fragment to the distance of the closest fragment in world space units
                If(currentDepth - bias > closestDepth)
                    shadow += 1.0;
                Fi
            Done

            shadow = shadow / fSamples;

            Return(1 - shadow);
        }
        EndFunction();
    }

    // TODO: Fix directional light shadows
    void sampleShadowDirectional() {
        Function("sampleShadowDirectional", {
                     {ShaderDataType::vec4(), "fragPosLightSpace"},
                     {ShaderTexture(TEXTURE_2D_ARRAY, DEPTH), "shadowMap"},
                     {ShaderDataType::Int(), "shadowMapIndex"},
                     {ShaderDataType::vec3(), "Normal"},
                     {ShaderDataType::vec3(), "lightPos"},
                     {ShaderDataType::vec3(), "fragPos"},
                 },
                 ShaderDataType::Float());
        {
            ARGUMENT(vec4, fragPosLightSpace)
            ARGUMENT(TextureSampler, shadowMap)
            ARGUMENT(Int, shadowMapIndex)
            ARGUMENT(vec3, Normal)
            ARGUMENT(vec3, lightPos)
            ARGUMENT(vec3, fragPos)

            // TODO: Make directional shadow map sampling compatible with generic NDC
            // perform perspective divide
            vec3 projCoords = fragPosLightSpace.xyz() / fragPosLightSpace.w();
            // transform to [0,1] range
            // This assumes ndc z coordinate range of -1 to 1 which is true for OpenGL but not for Vulkan (0 to 1)
            projCoords = projCoords * 0.5f + 0.5f;

            // Check if position is outside projection
            If(projCoords.x() < 0
                || projCoords.x() > 1
                || projCoords.y() < 0
                || projCoords.y() > 1
                || projCoords.z() > 1)
                Return(1.0f);
            Fi

            // get depth of current fragment from light's perspective
            Float currentDepth = projCoords.z();

            // TODO: Fix bias calculation
            // calculate bias (based on depth map resolution and slope)
            vec3 normal = normalize(Normal);
            vec3 lightDir = normalize(lightPos - fragPos);
            Float bias = max(0.01f * (1.0f - dot(normal, lightDir)), 0.001f);
            bias = Float(0.001f);
            // Single Sample
            /*{
                // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
                Float closestDepth = texture(shadowMap, vec3(projCoords.xy(), shadowMapIndex)).x();
                If(currentDepth - bias > closestDepth);
                {
                    Return(0.0f);
                }
                Else();
                {
                    Return(1.0f);
                }
                EndIf();
            }*/

            // PCF
            {
                Float shadow;
                shadow = Float(0.0f);
                vec2 texelSize = 1.0f / textureSize(shadowMap, 0).xy();
                For(Int, x, -1, x <= 1, x + 1)
                    For(Int, y, -1, y <= 1, y + 1)
                        vec2 coords = projCoords.xy() + vec2(x, y) * texelSize;
                        coords.y() = 1.0f - coords.y();
                        Float pcfDepth = textureSampleArray(shadowMap, vec3(coords, shadowMapIndex)).
                                x();
                        If(currentDepth - bias > pcfDepth)
                            shadow += 1.0f;
                        Fi
                    Done
                Done

                shadow /= 9.0f;

                Return(1.0f - shadow);
            }
        }
        EndFunction();
    }
}
