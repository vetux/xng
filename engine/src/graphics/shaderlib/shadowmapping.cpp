/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2025 Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.

 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "xng/graphics/shaderlib/shadowmapping.hpp"

#include "xng/rendergraph/shaderscript/shaderscript.hpp"

using namespace xng::ShaderScript;

namespace xng::shaderlib::shadowmapping {
    void sampleShadowPoint() {
        Function("sampleShadowPoint", {
                     {"fragPos", ShaderDataType::vec3()},
                     {"lightPos", ShaderDataType::vec3()},
                     {"viewPos", ShaderDataType::vec3()},
                     {"depthMap", ShaderTexture(TEXTURE_CUBE_MAP_ARRAY, DEPTH)},
                     {"depthMapIndex", ShaderDataType::integer()},
                     {"far_plane", ShaderDataType::float32()}
                 },
                 ShaderDataType::float32());
        {
            ARGUMENT(fragPos)
            ARGUMENT(lightPos)
            ARGUMENT(viewPos)
            ARGUMENT(depthMap)
            ARGUMENT(depthMapIndex)
            ARGUMENT(far_plane)

            ArrayVec3<20> gridSamplingDisk;
            gridSamplingDisk = std::vector{
                vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),
                vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
                vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0),
                vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
                vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1)
            };

            Int samples = 20;
            Float fSamples = 20.0f;

            vec3 fragToLight = fragPos - lightPos;
            fragToLight.z() *= -1;

            Float currentDepth = length(fragToLight);

            Float shadow;
            shadow = Float(0.0f);

            //TODO: Fix point shadows artifacts (Visible steps in the shadow fade)
            //TODO: Configurable shadow bias

            // The bias applied to the currentDepth in world space units.
            Float bias = Float(0.15f);

            Float viewDistance = length(viewPos - fragPos);
            Float diskRadius = (1.0 + (viewDistance / far_plane)) / far_plane;

            Int i;
            i = Int(0);
            For(i, 0, samples - 1, 1);
            {
                vec3 sampleDir = fragToLight + gridSamplingDisk[i] * diskRadius;
                Float closestDepth = textureSampleCubeArray(depthMap, vec4(sampleDir, depthMapIndex)).x();

                // closestDepth contains linear depth produced by the shadow mapping pass.

                // Convert depth into a world space distance by multiplying by far_plane.
                // This works because the shadow map is generated by manually writing linear depth values
                // which represent the distance of the fragment to the light in the range 0(Light Position) : Far Plane.
                closestDepth *= far_plane;

                // Compare the distance of the fragment to the distance of the closest fragment in world space units
                If(currentDepth - bias > closestDepth);
                {
                    shadow += 1.0;
                }
                EndIf();
            }
            EndFor();

            shadow = shadow / fSamples;

            Return(1 - shadow);
        }
        EndFunction();
    }

    // TODO: Fix directional light shadows
    void sampleShadowDirectional() {
        Function("sampleShadowDirectional", {
                     {"fragPosLightSpace", ShaderDataType::vec4()},
                     {"shadowMap", ShaderTexture(TEXTURE_2D_ARRAY, DEPTH)},
                     {"shadowMapIndex", ShaderDataType::integer()},
                     {"Normal", ShaderDataType::vec3()},
                     {"lightPos", ShaderDataType::vec3()},
                     {"fragPos", ShaderDataType::vec3()},
                 },
                 ShaderDataType::float32());
        {
            ARGUMENT(fragPosLightSpace)
            ARGUMENT(shadowMap)
            ARGUMENT(shadowMapIndex)
            ARGUMENT(Normal)
            ARGUMENT(lightPos)
            ARGUMENT(fragPos)

            // TODO: Make directional shadow map sampling compatible with generic NDC
            // perform perspective divide
            vec3 projCoords = fragPosLightSpace.xyz() / fragPosLightSpace.w();
            // transform to [0,1] range
            // This assumes ndc z coordinate range of -1 to 1 which is true for OpenGL but not for Vulkan (0 to 1)
            projCoords = projCoords * 0.5f + 0.5f;

            // Check if position is outside projection
            If(projCoords.x() < 0
               || projCoords.x() > 1
               || projCoords.y() < 0
               || projCoords.y() > 1
               || projCoords.z() > 1);
            {
                Return(1.0f);
            }
            EndIf();

            // get depth of current fragment from light's perspective
            Float currentDepth = projCoords.z();

            // TODO: Fix bias calculation
            // calculate bias (based on depth map resolution and slope)
            vec3 normal = normalize(Normal);
            vec3 lightDir = normalize(lightPos - fragPos);
            Float bias = max(0.01f * (1.0f - dot(normal, lightDir)), 0.001f);
            bias = Float(0.001f);
            // Single Sample
            /*{
                // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
                Float closestDepth = texture(shadowMap, vec3(projCoords.xy(), shadowMapIndex)).x();
                If(currentDepth - bias > closestDepth);
                {
                    Return(0.0f);
                }
                Else();
                {
                    Return(1.0f);
                }
                EndIf();
            }*/

            // PCF
            {
                Float shadow;
                shadow = Float(0.0f);
                vec2 texelSize = 1.0f / textureSize(shadowMap, 0).xy();
                Int x;
                x = Int(0);
                For(x, -1, 1, 1);
                {
                    Int y;
                    y = Int(0);
                    For(y, -1, 1, 1);
                    {
                        vec2 coords = projCoords.xy() + vec2(x, y) * texelSize;
                        coords.y() = 1.0f - coords.y();
                        Float pcfDepth = textureSampleArray(shadowMap, vec3(coords, shadowMapIndex)).
                                x();
                        If(currentDepth - bias > pcfDepth);
                        {
                            shadow += 1.0f;
                        }
                        EndIf();
                    }
                    EndFor();
                }
                EndFor();

                shadow /= 9.0f;

                Return(1.0f - shadow);
            }
        }
        EndFunction();
    }
}
