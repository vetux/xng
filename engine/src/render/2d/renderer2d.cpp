/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2023  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "xng/render/camera.hpp"
#include "xng/render/2d/renderer2d.hpp"

#include <utility>

#include "xng/math/matrixmath.hpp"
#include "xng/asset/shadersource.hpp"

#include "xng/geometry/vertexstream.hpp"

#include "ren2d/vs.hpp" // Generated by cmake
#include "ren2d/fs.hpp" // Generated by cmake
#include "ren2d/vs_compat.hpp" // Generated by cmake
#include "ren2d/fs_compat.hpp" // Generated by cmake

//TODO: Fix Renderer2D not drawing all multi draw primitives on Mesa 22.3.6 (Works fine on 20.3.5 and windows.)

static float distance(float val1, float val2) {
    float abs = val1 - val2;
    if (abs < 0)
        return abs * -1;
    else
        return abs;
}

namespace xng {
#pragma pack(push, 1)
    // If anything other than 4 component vectors are used in uniform buffer data the memory layout becomes unpredictable.
    struct PassData {
        float color[4];
        float colorMixFactor_alphaMixFactor_colorFactor[4];
        int texAtlasLevel_texAtlasIndex_texFilter[4]{-1, -1, 0, 0};
        Mat4f mvp;
        float uvOffset_uvScale[4];
        float atlasScale_texSize[4];
    };
#pragma pack(pop)

    static_assert(sizeof(PassData) % 16 == 0);

    /**
     * A draw cycle consists of one or more draw batches.
     *
     * Each draw batch contains draw calls which are dispatched using multiDraw or plain draw.
     *
     * To ensure correct blending consequent draw calls of the same primitive are drawn in the same batch
     * together but each change in primitive causes a new draw batch to be created which incurs the overhead of
     * updating the shader uniform buffer.
     */
    struct DrawBatch {
        std::vector<DrawCall> drawCalls;
        std::vector<size_t> baseVertices;
        Primitive primitive = TRIANGLES;
        std::vector<PassData> uniformBuffers; // The uniform buffer data for this batch
    };

    Renderer2D::Renderer2D(RenderDevice &device, ShaderCompiler &shaderCompiler, ShaderDecompiler &shaderDecompiler)
            : renderDevice(device) {
        vertexLayout.attributes.emplace_back(VertexAttribute(VertexAttribute::VECTOR2, VertexAttribute::FLOAT));
        vertexLayout.attributes.emplace_back(VertexAttribute(VertexAttribute::VECTOR2, VertexAttribute::FLOAT));

        VertexBufferDesc vertexBufferDesc;
        vertexBufferDesc.size = 0;
        vertexBuffer = renderDevice.createVertexBuffer(vertexBufferDesc);

        IndexBufferDesc indexBufferDesc;
        indexBufferDesc.size = 0;
        indexBuffer = renderDevice.createIndexBuffer(indexBufferDesc);

        vaoChange = true;

        VertexArrayObjectDesc vertexArrayObjectDesc;
        vertexArrayObjectDesc.vertexLayout = VertexLayout(vertexLayout);
        vertexArrayObject = renderDevice.createVertexArrayObject(vertexArrayObjectDesc);

        RenderPipelineDesc desc;

        desc.shaders = {
                {ShaderStage::VERTEX,   vs_compat},
                {ShaderStage::FRAGMENT, fs_compat}
        };
        desc.bindings = {
                RenderPipelineBindingType::BIND_SHADER_UNIFORM_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
        };

        desc.vertexLayout = VertexLayout(vertexLayout);
        desc.enableBlending = true;
        desc.depthTestWrite = true;

        desc.primitive = TRIANGLES;
        trianglePipeline = device.createRenderPipeline(desc, shaderDecompiler);

        desc.primitive = LINES;
        linePipeline = device.createRenderPipeline(desc, shaderDecompiler);

        desc.primitive = POINTS;
        pointPipeline = device.createRenderPipeline(desc, shaderDecompiler);

        desc.shaders = {
                {ShaderStage::VERTEX,   vs},
                {ShaderStage::FRAGMENT, fs}
        };
        desc.bindings = {
                RenderPipelineBindingType::BIND_SHADER_STORAGE_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
                RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
        };

        desc.primitive = TRIANGLES;
        trianglePipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

        desc.primitive = LINES;
        linePipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

        desc.primitive = POINTS;
        pointPipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

        for (int i = TEXTURE_ATLAS_8x8; i < TEXTURE_ATLAS_END; i++) {
            auto res = (TextureAtlasResolution) i;
            TextureArrayBufferDesc atlasDesc;
            atlasDesc.textureDesc.size = TextureAtlas::getResolutionLevelSize(res);
            atlasDesc.textureDesc.generateMipmap = true;
            atlasTextures[res] = std::move(device.createTextureArrayBuffer(atlasDesc));
        }

        RenderPassDesc passDesc;
        passDesc.numberOfColorAttachments = 1;
        passDesc.hasDepthStencilAttachment = false;
        renderPass = device.createRenderPass(passDesc);

        commandBuffer = device.createCommandBuffer();

        updateAtlasRef();
    }

    Renderer2D::~Renderer2D() = default;

    TextureAtlasHandle Renderer2D::createTexture(const ImageRGBA &texture) {
        auto res = TextureAtlas::getClosestMatchingResolutionLevel(texture.getSize());
        auto free = atlas.getFreeSlotCount(res);
        if (free < 1) {
            auto desc = atlasTextures.at(res)->getDescription();
            desc.textureCount += 1;
            auto buf = std::move(atlasTextures.at(res));
            atlasTextures.at(res) = renderDevice.createTextureArrayBuffer(desc);
            commandBuffer->begin();
            commandBuffer->add({atlasTextures.at(res)->copy(*buf)});
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
            auto occupations = atlas.getBufferOccupations();
            occupations[res].resize(desc.textureCount, false);
            atlas = TextureAtlas(occupations);
            updateAtlasRef();
        }
        auto ret = atlas.add(texture);
        TextureAtlas::upload(ret, atlasRef, texture);
        return ret;
    }

    std::vector<TextureAtlasHandle> Renderer2D::createTextures(const std::vector<ImageRGBA> &textures) {
        std::map<TextureAtlasResolution, size_t> resolutionCounts;
        for (auto &img: textures) {
            auto res = TextureAtlas::getClosestMatchingResolutionLevel(img.getSize());
            resolutionCounts[res]++;
        }
        for (auto &pair: resolutionCounts) {
            auto free = atlas.getFreeSlotCount(pair.first);
            if (free < pair.second) {
                auto desc = atlasTextures.at(pair.first)->getDescription();
                desc.textureCount += pair.second - free;
                auto buffer = renderDevice.createTextureArrayBuffer(desc);

                commandBuffer->begin();
                commandBuffer->add(buffer->copy(*atlasTextures.at(pair.first)));
                commandBuffer->end();
                renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});

                atlasTextures.at(pair.first) = std::move(buffer);
                auto occupations = atlas.getBufferOccupations();
                occupations[pair.first].resize(desc.textureCount, false);
                atlas = TextureAtlas(occupations);
                updateAtlasRef();
            }
        }
        std::vector<TextureAtlasHandle> ret;
        ret.reserve(textures.size());
        for (auto &img: textures) {
            auto r = atlas.add(img);
            TextureAtlas::upload(r, atlasRef, img);
            ret.emplace_back(r);
        }
        return ret;
    }

    void Renderer2D::destroyTexture(const TextureAtlasHandle &handle) {
        atlas.remove(handle);
    }

    void Renderer2D::renderBegin(RenderTarget &target,
                                 bool clear,
                                 const ColorRGBA &clearColor,
                                 const Vec2i &viewportOffset,
                                 const Vec2i &viewportSize,
                                 const Vec2f &cameraPosition,
                                 const Rectf &projection) {
        if (isRendering) {
            throw std::runtime_error("Already Rendering (Nested Renderer2D::renderBegin calls?)");
        }
        isRendering = true;
        mViewportOffset = viewportOffset;
        mViewportSize = viewportSize;
        mClear = clear;
        mClearColor = clearColor;

        auto prevCam = camera;

        camera.type = ORTHOGRAPHIC;
        camera.left = projection.position.x;
        camera.right = projection.dimensions.x;
        camera.top = projection.position.y;
        camera.bottom = projection.dimensions.y;

        cameraTransform.setPosition({cameraPosition.x, cameraPosition.y, 1});

        if (camera != prevCam ||
            cameraPosition != Vec2f{cameraTransform.getPosition().x, cameraTransform.getPosition().y}) {
            viewProjectionMatrix = camera.projection() * Camera::view(cameraTransform);
        }

        mTarget = &target;
    }

    void Renderer2D::renderPresent() {
        if (!isRendering) {
            throw std::runtime_error("Not Rendering");
        }
        isRendering = false;

        auto caps = renderDevice.getInfo().capabilities;

        if (caps.find(CAPABILITY_BASE_VERTEX) == caps.end()) {
            throw std::runtime_error("CAPABILITY_BASE_VERTEX is required");
        }

        if (mClear) {
            commandBuffer->begin();
            commandBuffer->add(renderPass->begin(*mTarget));
            commandBuffer->add(renderPass->clearColorAttachments(mClearColor));
            commandBuffer->add(renderPass->clearDepthAttachment(1));
            commandBuffer->add(renderPass->end());
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
        }

        if (caps.find(CAPABILITY_MULTI_DRAW) != caps.end()) {
            presentMultiDraw();
        } else {
            presentCompat();
        }

        passes.clear();
    }

    void Renderer2D::draw(const Rectf &srcRect,
                          const Rectf &dstRect,
                          TextureAtlasHandle &sprite,
                          const Vec2f &center,
                          float rotation,
                          TextureFiltering filter,
                          float mix,
                          float mixAlpha,
                          ColorRGBA mixColor) {
        passes.emplace_back(Pass(srcRect,
                                 dstRect,
                                 sprite,
                                 center,
                                 rotation,
                                 filter,
                                 mix,
                                 mixAlpha,
                                 mixColor));
    }

    void Renderer2D::draw(const Rectf &srcRect,
                          const Rectf &dstRect,
                          TextureAtlasHandle &sprite,
                          const Vec2f &center,
                          float rotation,
                          TextureFiltering filter,
                          ColorRGBA colorFactor) {
        passes.emplace_back(Pass(srcRect,
                                 dstRect,
                                 sprite,
                                 center,
                                 rotation,
                                 filter,
                                 colorFactor));
    }

    void Renderer2D::draw(const Rectf &rectangle, ColorRGBA color, bool fill, const Vec2f &center, float rotation) {
        passes.emplace_back(Pass(rectangle, color, fill, center, rotation));
    }

    void
    Renderer2D::draw(const Vec2f &start, const Vec2f &end, ColorRGBA color, const Vec2f &position, const Vec2f &center,
                     float rotation) {
        passes.emplace_back(Pass(start, end, color, position, center, rotation));
    }

    void Renderer2D::draw(const Vec2f &point,
                          ColorRGBA color,
                          const Vec2f &position,
                          const Vec2f &center,
                          float rotation) {
        passes.emplace_back(Pass(point, color, position, center, rotation));
    }

    void Renderer2D::updateAtlasRef() {
        atlasRef.insert_or_assign(TEXTURE_ATLAS_8x8, *atlasTextures.at(TEXTURE_ATLAS_8x8).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_16x16, *atlasTextures.at(TEXTURE_ATLAS_16x16).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_32x32, *atlasTextures.at(TEXTURE_ATLAS_32x32).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_64x64, *atlasTextures.at(TEXTURE_ATLAS_64x64).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_128x128, *atlasTextures.at(TEXTURE_ATLAS_128x128).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_256x256, *atlasTextures.at(TEXTURE_ATLAS_256x256).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_512x512, *atlasTextures.at(TEXTURE_ATLAS_512x512).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_1024x1024, *atlasTextures.at(TEXTURE_ATLAS_1024x1024).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_2048x2048, *atlasTextures.at(TEXTURE_ATLAS_2048x2048).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_4096x4096, *atlasTextures.at(TEXTURE_ATLAS_4096x4096).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_8192x8192, *atlasTextures.at(TEXTURE_ATLAS_8192x8192).get());
        atlasRef.insert_or_assign(TEXTURE_ATLAS_16384x16384, *atlasTextures.at(TEXTURE_ATLAS_16384x16384).get());
    }

    void Renderer2D::presentCompat() {
        // Compatibility render path for OpenGL ES 3.2

        usedPlanes.clear();
        usedSquares.clear();
        usedLines.clear();
        usedPoints.clear();
        usedRotationMatrices.clear();

        std::vector<DrawCall> drawCalls;
        std::vector<size_t> baseVertices;
        std::vector<Primitive> primitives;
        std::vector<PassData> passData;

        for (auto &pass: passes) {
            switch (pass.type) {
                case Pass::COLOR_POINT: {
                    usedPoints.insert(pass.dstRect.position);
                    auto point = getPoint(pass.dstRect.position);

                    primitives.emplace_back(point.primitive);
                    baseVertices.emplace_back(point.baseVertex);
                    drawCalls.emplace_back(point.drawCall);

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.srcRect.position.x,
                                                               pass.srcRect.position.y,
                                                               0})
                                 * rotMat;

                    PassData buffer;

                    buffer.mvp = viewProjectionMatrix * model;

                    auto color = pass.color.divide();
                    buffer.color[0] = color.x;
                    buffer.color[1] = color.y;
                    buffer.color[2] = color.z;
                    buffer.color[3] = color.w;

                    passData.emplace_back(buffer);

                    break;
                }
                case Pass::COLOR_LINE: {
                    usedLines.insert(std::make_pair(pass.dstRect.position, pass.dstRect.dimensions));

                    auto line = getLine(pass.dstRect.position, pass.dstRect.dimensions);

                    primitives.emplace_back(line.primitive);
                    baseVertices.emplace_back(line.baseVertex);
                    drawCalls.emplace_back(line.drawCall);

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.srcRect.position.x,
                                                               pass.srcRect.position.y,
                                                               0})
                                 * rotMat;

                    PassData buffer;

                    buffer.mvp = viewProjectionMatrix * model;
                    auto color = pass.color.divide();
                    buffer.color[0] = color.x;
                    buffer.color[1] = color.y;
                    buffer.color[2] = color.z;
                    buffer.color[3] = color.w;

                    passData.emplace_back(buffer);
                    break;
                }
                case Pass::COLOR_PLANE: {
                    if (pass.fill) {
                        usedPlanes.insert(pass.dstRect.dimensions);
                        auto plane = getPlane(pass.dstRect.dimensions);

                        primitives.emplace_back(plane.primitive);
                        baseVertices.emplace_back(plane.baseVertex);
                        drawCalls.emplace_back(plane.drawCall);
                    } else {
                        usedSquares.insert(pass.dstRect.dimensions);
                        auto square = getSquare(pass.dstRect.dimensions);

                        primitives.emplace_back(square.primitive);
                        baseVertices.emplace_back(square.baseVertex);
                        drawCalls.emplace_back(square.drawCall);
                    }

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.dstRect.position.x,
                                                               pass.dstRect.position.y,
                                                               0})
                                 * rotMat;

                    PassData buffer;

                    buffer.mvp = viewProjectionMatrix * model;
                    auto color = pass.color.divide();
                    buffer.color[0] = color.x;
                    buffer.color[1] = color.y;
                    buffer.color[2] = color.z;
                    buffer.color[3] = color.w;

                    passData.emplace_back(buffer);
                    break;
                }
                case Pass::TEXTURE: {
                    usedPlanes.insert(pass.dstRect.dimensions);
                    auto plane = getPlane(pass.dstRect.dimensions);

                    primitives.emplace_back(plane.primitive);
                    baseVertices.emplace_back(plane.baseVertex);
                    drawCalls.emplace_back(plane.drawCall);

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.dstRect.position.x,
                                                               pass.dstRect.position.y,
                                                               0})
                                 * rotMat;

                    PassData buffer;

                    buffer.mvp = viewProjectionMatrix * model;

                    auto color = pass.color.divide();
                    buffer.color[0] = color.x;
                    buffer.color[1] = color.y;
                    buffer.color[2] = color.z;
                    buffer.color[3] = color.w;

                    buffer.colorMixFactor_alphaMixFactor_colorFactor[0] = pass.mix;
                    buffer.colorMixFactor_alphaMixFactor_colorFactor[1] = pass.alphaMix;
                    buffer.colorMixFactor_alphaMixFactor_colorFactor[2] = pass.colorFactor;
                    buffer.texAtlasLevel_texAtlasIndex_texFilter[0] = pass.texture.level;
                    buffer.texAtlasLevel_texAtlasIndex_texFilter[1] = (int) pass.texture.index;
                    buffer.texAtlasLevel_texAtlasIndex_texFilter[2] = pass.filter == LINEAR ? 1 : 0;
                    auto uvOffset = pass.srcRect.position / pass.texture.size.convert<float>();
                    buffer.uvOffset_uvScale[0] = uvOffset.x;
                    buffer.uvOffset_uvScale[1] = uvOffset.y;
                    auto uvScale = (pass.srcRect.dimensions /
                                    pass.texture.size.convert<float>());
                    buffer.uvOffset_uvScale[2] = uvScale.x;
                    buffer.uvOffset_uvScale[3] = uvScale.y;
                    auto atlasScale = (pass.texture.size.convert<float>() /
                                       TextureAtlas::getResolutionLevelSize(
                                               pass.texture.level).convert<float>());
                    buffer.atlasScale_texSize[0] = atlasScale.x;
                    buffer.atlasScale_texSize[1] = atlasScale.y;
                    buffer.atlasScale_texSize[2] = static_cast<float>(pass.texture.size.x);
                    buffer.atlasScale_texSize[3] = static_cast<float>(pass.texture.size.y);

                    passData.emplace_back(buffer);

                    break;
                }
            }
        }

        std::unordered_set<Vec2f> unusedPlanes;
        std::unordered_set<Vec2f> unusedSquares;
        std::unordered_set<std::pair<Vec2f, Vec2f>, LinePairHash> unusedLines;
        std::unordered_set<Vec2f> unusedPoints;
        std::unordered_set<std::pair<float, Vec2f>, RotationPairHash> unusedRotationMatrices;

        for (auto &pair: planeMeshes) {
            if (usedPlanes.find(pair.first) == usedPlanes.end()) {
                unusedPlanes.insert(pair.first);
            }
        }

        for (auto &pair: squareMeshes) {
            if (usedSquares.find(pair.first) == usedSquares.end()) {
                unusedSquares.insert(pair.first);
            }
        }

        for (auto &pair: lineMeshes) {
            if (usedLines.find(pair.first) == usedLines.end()) {
                unusedLines.insert(pair.first);
            }
        }

        for (auto &pair: pointMeshes) {
            if (usedPoints.find(pair.first) == usedPoints.end()) {
                unusedPoints.insert(pair.first);
            }
        }

        for (auto &pair: rotationMatrices) {
            if (usedRotationMatrices.find(pair.first) == usedRotationMatrices.end()) {
                unusedRotationMatrices.insert(pair.first);
            }
        }

        for (auto &v: unusedPlanes) {
            destroyPlane(v);
        }

        for (auto &v: unusedSquares) {
            destroySquare(v);
        }

        for (auto &v: unusedLines) {
            destroyLine(v.first, v.second);
        }

        for (auto &v: unusedPoints) {
            destroyPoint(v);
        }

        for (auto &v: unusedRotationMatrices) {
            rotationMatrices.erase(v);
        }

        mergeFreeVertexBufferRanges();
        mergeFreeIndexBufferRanges();

        updateVertexArrayObject();

        std::vector<std::unique_ptr<ShaderUniformBuffer>> shaderBuffers;
        shaderBuffers.reserve(drawCalls.size());

        std::vector<DrawBatch> batches;
        DrawBatch currentBatch;
        for (auto y = 0; y < drawCalls.size(); y++) {
            auto prim = primitives.at(y);
            if (prim != currentBatch.primitive) {
                if (!currentBatch.drawCalls.empty())
                    batches.emplace_back(currentBatch);
                currentBatch = {};
                currentBatch.primitive = prim;
            }
            currentBatch.drawCalls.emplace_back(drawCalls.at(y));
            currentBatch.baseVertices.emplace_back(baseVertices.at(y));
            currentBatch.uniformBuffers.emplace_back(passData.at(y));

            ShaderUniformBufferDesc shaderBufferDesc;
            shaderBufferDesc.size = sizeof(PassData);
            shaderBuffers.emplace_back(renderDevice.createShaderUniformBuffer(shaderBufferDesc));
            shaderBuffers.at(shaderBuffers.size() - 1)->upload(passData.at(y));
        }
        if (!currentBatch.drawCalls.empty())
            batches.emplace_back(currentBatch);

        auto drawCallIndex = 0;
        for (auto &batch: batches) {
            std::vector<Command> commands;

            commands.emplace_back(renderPass->begin(*mTarget));
            commands.emplace_back(renderPass->setViewport(mViewportOffset, mViewportSize));

            switch (batch.primitive) {
                case POINTS:
                    commands.emplace_back(pointPipeline->bind());
                    break;
                case LINES:
                    commands.emplace_back(linePipeline->bind());
                    break;
                case TRIANGLES:
                    commands.emplace_back(trianglePipeline->bind());
                    break;
                default:
                    throw std::runtime_error("Unsupported primitive");
            }

            commands.emplace_back(vertexArrayObject->bind());

            for (auto y = 0; y < batch.drawCalls.size(); y++) {
                auto resources = std::vector<ShaderResource>{
                        {*shaderBuffers.at(
                                drawCallIndex++),                      {{VERTEX, ShaderResource::READ}, {FRAGMENT, ShaderResource::READ}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_8x8),         {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_16x16),       {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_32x32),       {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_64x64),       {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_128x128),     {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_256x256),     {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_512x512),     {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_1024x1024),   {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_2048x2048),   {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_4096x4096),   {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_8192x8192),   {{{FRAGMENT, ShaderResource::READ}}}},
                        {*atlasTextures.at(TEXTURE_ATLAS_16384x16384), {{{FRAGMENT, ShaderResource::READ}}}},
                };

                commands.emplace_back(RenderPipeline::bindShaderResources(resources));
                commands.emplace_back(renderPass->drawIndexed(batch.drawCalls.at(y), batch.baseVertices.at(y)));
            }

            commands.emplace_back(renderPass->end());

            commandBuffer->begin();
            commandBuffer->add(commands);
            commandBuffer->end();

            renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
        }
    }

    void Renderer2D::presentMultiDraw() {
        size_t totalBufferSize = passes.size() * sizeof(PassData);
        size_t maxBufferSize = renderDevice.getInfo().storageBufferMaxSize;

        size_t drawCycles = 0;
        if (totalBufferSize > maxBufferSize) {
            drawCycles = totalBufferSize / maxBufferSize;
            auto remainder = totalBufferSize % maxBufferSize;
            if (remainder > 0) {
                drawCycles += 1;
            }
        } else if (!passes.empty()) {
            drawCycles = 1;
        }

        size_t numberOfPassesPerCycle = maxBufferSize / sizeof(PassData);

        for (int i = 0; i < drawCycles; i++) {
            usedPlanes.clear();
            usedSquares.clear();
            usedLines.clear();
            usedPoints.clear();
            usedRotationMatrices.clear();

            std::vector<DrawCall> drawCalls;
            std::vector<size_t> baseVertices;
            std::vector<Primitive> primitives;
            std::vector<PassData> passData;

            auto currentPassBase = i * numberOfPassesPerCycle;
            for (auto passIndex = 0;
                 passIndex < numberOfPassesPerCycle && passIndex + currentPassBase < passes.size();
                 passIndex++) {
                auto &pass = passes.at(passIndex + currentPassBase);
                PassData data;
                switch (pass.type) {
                    case Pass::COLOR_POINT: {
                        usedPoints.insert(pass.dstRect.position);
                        auto point = getPoint(pass.dstRect.position);

                        primitives.emplace_back(point.primitive);
                        baseVertices.emplace_back(point.baseVertex);
                        drawCalls.emplace_back(point.drawCall);


                        auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                        auto model = MatrixMath::translate({
                                                                   pass.srcRect.position.x,
                                                                   pass.srcRect.position.y,
                                                                   0})
                                     * rotMat;

                        data.mvp = viewProjectionMatrix * model;
                        auto color = pass.color.divide();
                        data.color[0] = color.x;
                        data.color[1] = color.y;
                        data.color[2] = color.z;
                        data.color[3] = color.w;
                        break;
                    }
                    case Pass::COLOR_LINE: {
                        usedLines.insert(std::make_pair(pass.dstRect.position, pass.dstRect.dimensions));

                        auto line = getLine(pass.dstRect.position, pass.dstRect.dimensions);

                        primitives.emplace_back(line.primitive);
                        baseVertices.emplace_back(line.baseVertex);
                        drawCalls.emplace_back(line.drawCall);


                        auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                        auto model = MatrixMath::translate({
                                                                   pass.srcRect.position.x,
                                                                   pass.srcRect.position.y,
                                                                   0})
                                     * rotMat;

                        data.mvp = viewProjectionMatrix * model;
                        auto color = pass.color.divide();
                        data.color[0] = color.x;
                        data.color[1] = color.y;
                        data.color[2] = color.z;
                        data.color[3] = color.w;
                        break;
                    }
                    case Pass::COLOR_PLANE: {
                        if (pass.fill) {
                            usedPlanes.insert(pass.dstRect.dimensions);
                            auto plane = getPlane(pass.dstRect.dimensions);

                            primitives.emplace_back(plane.primitive);
                            baseVertices.emplace_back(plane.baseVertex);
                            drawCalls.emplace_back(plane.drawCall);
                        } else {
                            usedSquares.insert(pass.dstRect.dimensions);
                            auto square = getSquare(pass.dstRect.dimensions);

                            primitives.emplace_back(square.primitive);
                            baseVertices.emplace_back(square.baseVertex);
                            drawCalls.emplace_back(square.drawCall);
                        }

                        auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                        auto model = MatrixMath::translate({
                                                                   pass.dstRect.position.x,
                                                                   pass.dstRect.position.y,
                                                                   0})
                                     * rotMat;

                        data.mvp = viewProjectionMatrix * model;
                        auto color = pass.color.divide();
                        data.color[0] = color.x;
                        data.color[1] = color.y;
                        data.color[2] = color.z;
                        data.color[3] = color.w;
                        break;
                    }
                    case Pass::TEXTURE: {
                        usedPlanes.insert(pass.dstRect.dimensions);
                        auto plane = getPlane(pass.dstRect.dimensions);

                        primitives.emplace_back(plane.primitive);
                        baseVertices.emplace_back(plane.baseVertex);
                        drawCalls.emplace_back(plane.drawCall);

                        auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                        auto model = MatrixMath::translate({
                                                                   pass.dstRect.position.x,
                                                                   pass.dstRect.position.y,
                                                                   0})
                                     * rotMat;

                        data.mvp = viewProjectionMatrix * model;

                        auto color = pass.color.divide();
                        data.color[0] = color.x;
                        data.color[1] = color.y;
                        data.color[2] = color.z;
                        data.color[3] = color.w;
                        data.colorMixFactor_alphaMixFactor_colorFactor[0] = pass.mix;
                        data.colorMixFactor_alphaMixFactor_colorFactor[1] = pass.alphaMix;
                        data.colorMixFactor_alphaMixFactor_colorFactor[2] = pass.colorFactor;
                        data.texAtlasLevel_texAtlasIndex_texFilter[0] = pass.texture.level;
                        data.texAtlasLevel_texAtlasIndex_texFilter[1] = (int) pass.texture.index;
                        data.texAtlasLevel_texAtlasIndex_texFilter[2] = pass.filter == LINEAR ? 1 : 0;
                        auto uvOffset = pass.srcRect.position / pass.texture.size.convert<float>();
                        data.uvOffset_uvScale[0] = uvOffset.x;
                        data.uvOffset_uvScale[1] = uvOffset.y;
                        auto uvScale = (pass.srcRect.dimensions /
                                        pass.texture.size.convert<float>());
                        data.uvOffset_uvScale[2] = uvScale.x;
                        data.uvOffset_uvScale[3] = uvScale.y;
                        auto atlasScale = (pass.texture.size.convert<float>() /
                                           TextureAtlas::getResolutionLevelSize(
                                                   pass.texture.level).convert<float>());
                        data.atlasScale_texSize[0] = atlasScale.x;
                        data.atlasScale_texSize[1] = atlasScale.y;
                        data.atlasScale_texSize[2] = static_cast<float>(pass.texture.size.x);
                        data.atlasScale_texSize[3] = static_cast<float>(pass.texture.size.y);
                        break;
                    }
                }
                passData.emplace_back(data);
            }

            std::unordered_set<Vec2f> unusedPlanes;
            std::unordered_set<Vec2f> unusedSquares;
            std::unordered_set<std::pair<Vec2f, Vec2f>, LinePairHash> unusedLines;
            std::unordered_set<Vec2f> unusedPoints;
            std::unordered_set<std::pair<float, Vec2f>, RotationPairHash> unusedRotationMatrices;

            for (auto &pair: planeMeshes) {
                if (usedPlanes.find(pair.first) == usedPlanes.end()) {
                    unusedPlanes.insert(pair.first);
                }
            }

            for (auto &pair: squareMeshes) {
                if (usedSquares.find(pair.first) == usedSquares.end()) {
                    unusedSquares.insert(pair.first);
                }
            }

            for (auto &pair: lineMeshes) {
                if (usedLines.find(pair.first) == usedLines.end()) {
                    unusedLines.insert(pair.first);
                }
            }

            for (auto &pair: pointMeshes) {
                if (usedPoints.find(pair.first) == usedPoints.end()) {
                    unusedPoints.insert(pair.first);
                }
            }

            for (auto &pair: rotationMatrices) {
                if (usedRotationMatrices.find(pair.first) == usedRotationMatrices.end()) {
                    unusedRotationMatrices.insert(pair.first);
                }
            }

            for (auto &v: unusedPlanes) {
                destroyPlane(v);
            }

            for (auto &v: unusedSquares) {
                destroySquare(v);
            }

            for (auto &v: unusedLines) {
                destroyLine(v.first, v.second);
            }

            for (auto &v: unusedPoints) {
                destroyPoint(v);
            }

            for (auto &v: unusedRotationMatrices) {
                rotationMatrices.erase(v);
            }

            mergeFreeVertexBufferRanges();
            mergeFreeIndexBufferRanges();

            updateVertexArrayObject();

            std::vector<DrawBatch> batches;
            DrawBatch currentBatch;

            for (auto y = 0; y < drawCalls.size(); y++) {
                auto prim = primitives.at(y);
                if (prim != currentBatch.primitive) {
                    if (!currentBatch.drawCalls.empty())
                        batches.emplace_back(currentBatch);
                    currentBatch = {};
                    currentBatch.primitive = prim;
                }
                currentBatch.drawCalls.emplace_back(drawCalls.at(y));
                currentBatch.baseVertices.emplace_back(baseVertices.at(y));
                currentBatch.uniformBuffers.emplace_back(passData.at(y));
            }

            if (!currentBatch.drawCalls.empty())
                batches.emplace_back(currentBatch);

            auto bufSize = sizeof(PassData) * numberOfPassesPerCycle;
            if (bufSize > totalBufferSize)
                bufSize = totalBufferSize;

            ShaderStorageBufferDesc shaderBufferDesc;
            shaderBufferDesc.size = bufSize;
            auto shaderBuffer = renderDevice.createShaderStorageBuffer(shaderBufferDesc);

            auto resources = std::vector<ShaderResource>{
                    {*shaderBuffer,                                {{VERTEX, ShaderResource::READ}, {FRAGMENT, ShaderResource::READ}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_8x8),         {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_16x16),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_32x32),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_64x64),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_128x128),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_256x256),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_512x512),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_1024x1024),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_2048x2048),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_4096x4096),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_8192x8192),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_16384x16384), {{{FRAGMENT, ShaderResource::READ}}}},
            };

            for (auto &batch: batches) {
                shaderBuffer->upload(0, reinterpret_cast<const uint8_t *>(batch.uniformBuffers.data()),
                                     batch.uniformBuffers.size() * sizeof(PassData));

                std::vector<Command> commands;

                commands.emplace_back(renderPass->begin(*mTarget));
                commands.emplace_back(renderPass->setViewport(mViewportOffset, mViewportSize));

                commands.emplace_back(vertexArrayObject->bind());

                switch (batch.primitive) {
                    case POINTS:
                        commands.emplace_back(pointPipelineMultiDraw->bind());
                        break;
                    case LINES:
                        commands.emplace_back(linePipelineMultiDraw->bind());
                        break;
                    case TRIANGLES:
                        commands.emplace_back(trianglePipelineMultiDraw->bind());
                        break;
                    default:
                        throw std::runtime_error("Unsupported primitive");
                }

                commands.emplace_back(RenderPipeline::bindShaderResources(resources));
                commands.emplace_back(renderPass->multiDrawIndexed(batch.drawCalls, batch.baseVertices));
                commands.emplace_back(renderPass->end());
                commandBuffer->begin();
                commandBuffer->add(commands);
                commandBuffer->end();
                renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
            }
        }
    }

    Renderer2D::MeshDrawData Renderer2D::getPlane(const Vec2f &size) {
        auto it = planeMeshes.find(size);
        if (it != planeMeshes.end()) {
            return it->second;
        } else {
            VertexStream vertexStream;

            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(0, 0))
                                           .addVec2(Vec2f(0, 0))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(size.x, 0))
                                           .addVec2(Vec2f(1, 0))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(0, size.y))
                                           .addVec2(Vec2f(0, 1))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(size.x,
                                                          size.y))
                                           .addVec2(Vec2f(1, 1))
                                           .build());

            auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

            vertexBuffer->upload(vertexBufferOffset,
                                 vertexStream.getVertexBuffer().data(),
                                 vertexStream.getVertexBuffer().size());

            std::vector<unsigned int> indices;
            indices.emplace_back(0);
            indices.emplace_back(1);
            indices.emplace_back(2);

            indices.emplace_back(1);
            indices.emplace_back(2);
            indices.emplace_back(3);

            auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

            auto drawCall = DrawCall(indexBufferOffset, indices.size());

            indexBuffer->upload(indexBufferOffset,
                                reinterpret_cast<const uint8_t *>(indices.data()),
                                indices.size() * sizeof(unsigned int));

            planeMeshes[size] = MeshDrawData{.primitive = TRIANGLES,
                    .drawCall = drawCall,
                    .baseVertex = vertexBufferOffset / vertexLayout.getSize()};

            return planeMeshes.at(size);
        }
    }

    Renderer2D::MeshDrawData Renderer2D::getSquare(const Vec2f &size) {
        auto it = squareMeshes.find(size);
        if (it != squareMeshes.end()) {
            return it->second;
        } else {
            VertexStream vertexStream;

            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(0, 0))
                                           .addVec2(Vec2f(0, 0))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(size.x, 0))
                                           .addVec2(Vec2f(1, 0))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(0, size.y))
                                           .addVec2(Vec2f(0, 1))
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(Vec2f(size.x,
                                                          size.y))
                                           .addVec2(Vec2f(1, 1))
                                           .build());

            auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

            vertexBuffer->upload(vertexBufferOffset,
                                 vertexStream.getVertexBuffer().data(),
                                 vertexStream.getVertexBuffer().size());

            std::vector<unsigned int> indices;
            indices.emplace_back(0);
            indices.emplace_back(1);

            indices.emplace_back(1);
            indices.emplace_back(3);

            indices.emplace_back(3);
            indices.emplace_back(2);

            indices.emplace_back(2);
            indices.emplace_back(0);

            auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

            auto drawCall = DrawCall(indexBufferOffset, indices.size());

            indexBuffer->upload(indexBufferOffset,
                                reinterpret_cast<const uint8_t *>(indices.data()),
                                indices.size() * sizeof(unsigned int));

            squareMeshes[size] = MeshDrawData{.primitive = LINES,
                    .drawCall = drawCall,
                    .baseVertex = vertexBufferOffset / vertexLayout.getSize()};

            return squareMeshes.at(size);
        }

    }

    Renderer2D::MeshDrawData Renderer2D::getLine(const Vec2f &start, const Vec2f &end) {
        auto pair = std::make_pair(start, end);
        auto it = lineMeshes.find(pair);
        if (it != lineMeshes.end()) {
            return it->second;
        } else {
            VertexStream vertexStream;

            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(start)
                                           .addVec2(Vec2f())
                                           .build());
            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(end)
                                           .addVec2(Vec2f())
                                           .build());

            auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

            vertexBuffer->upload(vertexBufferOffset,
                                 vertexStream.getVertexBuffer().data(),
                                 vertexStream.getVertexBuffer().size());

            std::vector<unsigned int> indices;
            indices.emplace_back(0);
            indices.emplace_back(1);

            auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

            auto drawCall = DrawCall(indexBufferOffset, indices.size());

            indexBuffer->upload(indexBufferOffset,
                                reinterpret_cast<const uint8_t *>(indices.data()),
                                indices.size() * sizeof(unsigned int));

            lineMeshes[pair] = MeshDrawData{.primitive = LINES,
                    .drawCall = drawCall,
                    .baseVertex = vertexBufferOffset / vertexLayout.getSize()};

            return lineMeshes.at(pair);
        }
    }

    Renderer2D::MeshDrawData Renderer2D::getPoint(const Vec2f &point) {
        auto it = pointMeshes.find(point);
        if (it != pointMeshes.end()) {
            return it->second;
        } else {
            VertexStream vertexStream;

            vertexStream.addVertex(VertexBuilder()
                                           .addVec2(point)
                                           .addVec2(Vec2f())
                                           .build());

            auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

            vertexBuffer->upload(vertexBufferOffset,
                                 vertexStream.getVertexBuffer().data(),
                                 vertexStream.getVertexBuffer().size());

            std::vector<unsigned int> indices;
            indices.emplace_back(0);

            auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

            auto drawCall = DrawCall(indexBufferOffset, indices.size());

            indexBuffer->upload(indexBufferOffset,
                                reinterpret_cast<const uint8_t *>(indices.data()),
                                indices.size() * sizeof(unsigned int));

            pointMeshes[point] = MeshDrawData{.primitive = POINTS,
                    .drawCall = drawCall,
                    .baseVertex = vertexBufferOffset / vertexLayout.getSize()};

            return pointMeshes.at(point);
        }
    }

    void Renderer2D::destroyPlane(const Vec2f &size) {
        auto drawData = planeMeshes.at(size);
        planeMeshes.erase(size);
        deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
        deallocateIndexData(drawData.drawCall.offset);
    }

    void Renderer2D::destroySquare(const Vec2f &size) {
        auto drawData = squareMeshes.at(size);
        squareMeshes.erase(size);
        deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
        deallocateIndexData(drawData.drawCall.offset);
    }

    void Renderer2D::destroyLine(const Vec2f &start, const Vec2f &end) {
        auto pair = std::make_pair(start, end);
        auto drawData = lineMeshes.at(pair);
        lineMeshes.erase(pair);
        deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
        deallocateIndexData(drawData.drawCall.offset);
    }

    void Renderer2D::destroyPoint(const Vec2f &point) {
        auto drawData = pointMeshes.at(point);
        pointMeshes.erase(point);
        deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
        deallocateIndexData(drawData.drawCall.offset);
    }

    size_t Renderer2D::allocateVertexData(size_t size) {
        bool foundFreeRange = false;
        auto ret = 0UL;
        for (auto &range: freeVertexBufferRanges) {
            if (range.second >= size) {
                ret = range.first;
                foundFreeRange = true;
            }
        }

        if (foundFreeRange) {
            auto rangeSize = freeVertexBufferRanges.at(ret) -= size;
            freeVertexBufferRanges.erase(ret);
            if (rangeSize > 0) {
                freeVertexBufferRanges[ret + size] = rangeSize;
            }
        } else {
            ret = vertexBuffer->getDescription().size;
        }

        if (vertexBuffer->getDescription().size <= ret
            || vertexBuffer->getDescription().size < ret + size) {
            VertexBufferDesc desc;
            desc.size = vertexBuffer->getDescription().size + size;
            auto nBuffer = renderDevice.createVertexBuffer(desc);
            if (vertexBuffer->getDescription().size > 0) {
                commandBuffer->begin();
                commandBuffer->add(nBuffer->copy(*vertexBuffer));
                commandBuffer->end();
                renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
            }
            vertexBuffer = std::move(nBuffer);
            vaoChange = true;
        }

        allocatedVertexRanges[ret] = size;

        return ret;
    }

    void Renderer2D::deallocateVertexData(size_t offset) {
        auto size = allocatedVertexRanges.at(offset);
        allocatedVertexRanges.erase(offset);
        freeVertexBufferRanges[offset] = size;
    }

    size_t Renderer2D::allocateIndexData(size_t size) {
        bool foundFreeRange = false;
        auto ret = 0UL;
        for (auto &range: freeIndexBufferRanges) {
            if (range.second >= size) {
                ret = range.first;
                foundFreeRange = true;
            }
        }
        if (foundFreeRange) {
            auto rangeSize = freeIndexBufferRanges.at(ret) -= size;
            freeIndexBufferRanges.erase(ret);
            if (rangeSize > 0) {
                freeIndexBufferRanges[ret + size] = rangeSize;
            }
        } else {
            ret = indexBuffer->getDescription().size;
        }

        if (indexBuffer->getDescription().size <= ret
            || indexBuffer->getDescription().size <= ret + size) {
            IndexBufferDesc desc;
            desc.size = indexBuffer->getDescription().size + size;
            auto nBuffer = renderDevice.createIndexBuffer(desc);
            if (indexBuffer->getDescription().size > 0) {
                commandBuffer->begin();
                commandBuffer->add(nBuffer->copy(*indexBuffer));
                commandBuffer->end();
                renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
            }
            indexBuffer = std::move(nBuffer);
            vaoChange = true;
        }

        allocatedIndexRanges[ret] = size;

        return ret;
    }

    void Renderer2D::deallocateIndexData(size_t offset) {
        auto size = allocatedIndexRanges.at(offset);
        allocatedIndexRanges.erase(offset);
        freeIndexBufferRanges[offset] = size;
    }

    void Renderer2D::mergeFreeVertexBufferRanges() {
        bool merged = true;
        while (merged) {
            merged = false;
            auto vertexRanges = freeVertexBufferRanges;
            for (auto range = freeVertexBufferRanges.begin(); range != freeVertexBufferRanges.end(); range++) {
                auto next = range;
                next++;
                if (next != freeVertexBufferRanges.end()) {
                    if (range->first + range->second == next->first
                        && vertexRanges.find(range->first) != vertexRanges.end()
                        && vertexRanges.find(next->first) != vertexRanges.end()) {
                        merged = true;
                        vertexRanges.at(range->first) += next->second;
                        vertexRanges.erase(next->first);
                        range = next;
                    }
                }
            }
            freeVertexBufferRanges = vertexRanges;
        }
    }

    void Renderer2D::mergeFreeIndexBufferRanges() {
        bool merged = true;
        while (merged) {
            merged = false;
            auto indexRanges = freeIndexBufferRanges;
            for (auto range = freeIndexBufferRanges.begin(); range != freeIndexBufferRanges.end(); range++) {
                auto next = range;
                next++;
                if (next != freeIndexBufferRanges.end()) {
                    if (range->first + range->second == next->first
                        && indexRanges.find(range->first) != indexRanges.end()
                        && indexRanges.find(next->first) != indexRanges.end()) {
                        merged = true;
                        indexRanges.at(range->first) += next->second;
                        indexRanges.erase(next->first);
                        range = next;
                    }
                }
            }
            freeIndexBufferRanges = indexRanges;
        }
    }

    void Renderer2D::updateVertexArrayObject() {
        if (vaoChange) {
            vaoChange = false;
            vertexArrayObject->setBuffers(*vertexBuffer, *indexBuffer);
        }
    }

    Mat4f Renderer2D::getRotationMatrix(float rotation, Vec2f center) {
        auto pair = std::make_pair(rotation, center);
        usedRotationMatrices.insert(pair);
        auto it = rotationMatrices.find(pair);
        if (it != rotationMatrices.end()) {
            return it->second;
        } else {
            rotationMatrices[pair] = MatrixMath::translate({
                                                                   center.x,
                                                                   center.y,
                                                                   0})
                                     * MatrixMath::rotate(Vec3f(0, 0, rotation))
                                     * MatrixMath::translate({
                                                                     -center.x,
                                                                     -center.y,
                                                                     0});
            return rotationMatrices.at(pair);
        }
    }
}