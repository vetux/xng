/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2024  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "xng/render/scene/camera.hpp"
#include "xng/render/2d/renderer2d.hpp"

#include <utility>

//TODO: Reimplement 2d renderer

namespace xng {
    Renderer2D::~Renderer2D() {
    }

    Texture2D Renderer2D::createTexture(const ImageRGBA &texture) {
        throw std::runtime_error("Not Implemented");
    }

    std::vector<Texture2D> Renderer2D::createTextures(const std::vector<ImageRGBA> &textures) {
        throw std::runtime_error("Not Implemented");
    }

    void Renderer2D::renderBegin(bool clear, const ColorRGBA &clearColor, const Vec2i &viewportOffset,
                                 const Vec2i &viewportSize, const Vec2f &cameraPosition, const Rectf &projection) {
    }

    void Renderer2D::renderPresent() {
    }

    void Renderer2D::draw(const Rectf &srcRect, const Rectf &dstRect, const Texture2D &texture, const Vec2f &center,
                          float rotation, TextureFiltering filter, ColorRGBA colorFactor) {
    }

    void Renderer2D::draw(const Rectf &srcRect, const Rectf &dstRect, const Texture2D &texture, const Vec2f &center,
                          float rotation, TextureFiltering filter, float mixRGB, float mixAlpha,
                          const ColorRGBA &mixColor) {
    }

    void Renderer2D::draw(const Rectf &rectangle, const ColorRGBA &color, bool fill, const Vec2f &center,
                          float rotation) {
    }

    void Renderer2D::draw(const Vec2f &start, const Vec2f &end, const ColorRGBA &color, const Vec2f &position,
                          const Vec2f &center, float rotation) {
    }

    void Renderer2D::draw(const Vec2f &point, const ColorRGBA &color, const Vec2f &position, const Vec2f &center,
                          float rotation) {
    }

    void Renderer2D::updateAtlasRef() {
    }

    void Renderer2D::present() {
    }

    void Renderer2D::presentMultiDraw() {
    }

    Renderer2D::MeshDrawData Renderer2D::getPlane(const Vec2f &size) {
        throw std::runtime_error("Not Implemented");
    }

    Renderer2D::MeshDrawData Renderer2D::getSquare(const Vec2f &size) {
        throw std::runtime_error("Not Implemented");
    }

    Renderer2D::MeshDrawData Renderer2D::getLine(const Vec2f &start, const Vec2f &end) {
        throw std::runtime_error("Not Implemented");
    }

    Renderer2D::MeshDrawData Renderer2D::getPoint(const Vec2f &point) {
        throw std::runtime_error("Not Implemented");
    }

    void Renderer2D::destroyPlane(const Vec2f &size) {
    }

    void Renderer2D::destroySquare(const Vec2f &size) {
    }

    void Renderer2D::destroyLine(const Vec2f &start, const Vec2f &end) {
    }

    void Renderer2D::destroyPoint(const Vec2f &point) {
    }

    size_t Renderer2D::allocateVertexData(size_t size) {
        throw std::runtime_error("Not Implemented");
    }

    void Renderer2D::deallocateVertexData(size_t offset) {
    }

    size_t Renderer2D::allocateIndexData(size_t size) {
        throw std::runtime_error("Not Implemented");
    }

    void Renderer2D::deallocateIndexData(size_t offset) {
    }

    void Renderer2D::mergeFreeVertexBufferRanges() {
    }

    void Renderer2D::mergeFreeIndexBufferRanges() {
    }

    void Renderer2D::updateVertexArrayObject() {
    }

    Mat4f Renderer2D::getRotationMatrix(float rotation, Vec2f center) {
        throw std::runtime_error("Not Implemented");
    }
}

/***
#include "xng/math/matrixmath.hpp"
#include "xng/shader/shadersource.hpp"

#include "xng/render/geometry/vertexstream.hpp"

#include "ren2d/vs.hpp" // Generated by cmake
#include "ren2d/fs.hpp" // Generated by cmake
#include "ren2d/vs_multi.hpp" // Generated by cmake
#include "ren2d/fs_multi.hpp" // Generated by cmake

static float distance(float val1, float val2) {
    float abs = val1 - val2;
    if (abs < 0)
        return abs * -1;
    else
        return abs;
}

namespace xng {
    static_assert(sizeof(float) == 4);
    static_assert(sizeof(int) == 4);

    struct PassData {
        alignas(16) float color[4]{};
        alignas(4) float colorMixFactor{};
        alignas(4) float alphaMixFactor{};
        alignas(4) float colorFactor{};
        alignas(4) int texAtlasLevel = -1;
        alignas(4) int texAtlasIndex = -1;
        alignas(4) int texFilter{};
        alignas(16) Mat4f mvp{};
        alignas(16) float uvOffset_uvScale[4]{};
        alignas(16) float atlasScale_texSize[4]{};
        alignas(4) float _padding{}; // Array stride in the ssbo must be 16 for std140 therefore we add this padding float
    };

    static_assert(sizeof(PassData) % 16 == 0);

    /**
     * A draw cycle consists of one or more draw batches.
     *
     * Each draw batch contains draw calls which are dispatched using multiDraw or plain draw.
     *
     * To ensure correct blending consequent draw calls of the same primitive are drawn in the same batch
     * together but each change in primitive causes a new draw batch to be created which incurs the overhead of
     * updating the shader uniform buffer.
     */
/*struct DrawBatch {
    std::vector<DrawCall> drawCalls;
    std::vector<size_t> baseVertices;
    Primitive primitive = TRIANGLES;
    std::vector<PassData> uniformBuffers; // The uniform buffer data for this batch
};

Renderer2D::Renderer2D(RenderDevice &device, ShaderCompiler &shaderCompiler, ShaderDecompiler &shaderDecompiler)
        : renderDevice(device) {
    vertexLayout.attributes.emplace_back(VertexAttribute::VECTOR2, VertexAttribute::FLOAT);
    vertexLayout.attributes.emplace_back(VertexAttribute::VECTOR2, VertexAttribute::FLOAT);

    VertexBufferDesc vertexBufferDesc;
    vertexBufferDesc.size = 0;
    vertexBuffer = renderDevice.createVertexBuffer(vertexBufferDesc);

    IndexBufferDesc indexBufferDesc;
    indexBufferDesc.size = 0;
    indexBuffer = renderDevice.createIndexBuffer(indexBufferDesc);

    vaoChange = true;

    VertexArrayObjectDesc vertexArrayObjectDesc;
    vertexArrayObjectDesc.vertexLayout = VertexLayout(vertexLayout);
    vertexArrayObject = renderDevice.createVertexArrayObject(vertexArrayObjectDesc);

    RenderPipelineDesc desc;

    desc.shaders = {
            {ShaderStage::VERTEX,   vs},
            {ShaderStage::FRAGMENT, fs}
    };
    desc.bindings = {
            RenderPipelineBindingType::BIND_SHADER_UNIFORM_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
    };

    desc.vertexLayout = VertexLayout(vertexLayout);
    desc.enableBlending = true;
    desc.depthTestWrite = true;

    desc.primitive = TRIANGLES;
    trianglePipeline = device.createRenderPipeline(desc, shaderDecompiler);

    desc.primitive = LINES;
    linePipeline = device.createRenderPipeline(desc, shaderDecompiler);

    desc.primitive = POINTS;
    pointPipeline = device.createRenderPipeline(desc, shaderDecompiler);

    desc.shaders = {
            {ShaderStage::VERTEX,   vs_multi},
            {ShaderStage::FRAGMENT, fs_multi}
    };
    desc.bindings = {
            RenderPipelineBindingType::BIND_SHADER_STORAGE_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
            RenderPipelineBindingType::BIND_TEXTURE_ARRAY_BUFFER,
    };

    desc.primitive = TRIANGLES;
    trianglePipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

    desc.primitive = LINES;
    linePipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

    desc.primitive = POINTS;
    pointPipelineMultiDraw = device.createRenderPipeline(desc, shaderDecompiler);

    for (int i = TEXTURE_ATLAS_8x8; i < TEXTURE_ATLAS_END; i++) {
        auto res = (TextureAtlasResolution) i;
        TextureArrayBufferDesc atlasDesc;
        atlasDesc.textureDesc.size = TextureAtlas::getResolutionLevelSize(res);
        atlasTextures[res] = std::move(device.createTextureArrayBuffer(atlasDesc));
    }

    RenderPassDesc passDesc;
    passDesc.numberOfColorAttachments = 1;
    passDesc.hasDepthStencilAttachment = false;
    renderPass = device.createRenderPass(passDesc);

    commandBuffer = device.createCommandBuffer();

    updateAtlasRef();
}

Renderer2D::~Renderer2D() = default;

Texture2D Renderer2D::createTexture(const ImageRGBA &texture) {
    auto res = TextureAtlas::getClosestMatchingResolutionLevel(texture.getResolution());
    auto free = atlas.getFreeSlotCount(res);
    if (free < 1) {
        auto desc = atlasTextures.at(res)->getDescription();
        desc.textureCount += 1;
        auto buf = std::move(atlasTextures.at(res));
        atlasTextures.at(res) = renderDevice.createTextureArrayBuffer(desc);
        commandBuffer->begin();
        commandBuffer->add({atlasTextures.at(res)->copy(*buf)});
        commandBuffer->end();
        renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
        auto occupations = atlas.getBufferOccupations();
        occupations[res].resize(desc.textureCount, false);
        atlas = TextureAtlas(occupations);
        updateAtlasRef();
    }
    auto ret = atlas.add(texture);
    TextureAtlas::upload(ret, atlasRef, texture);

    return {std::make_shared<Texture2D::Deallocator>([this, ret]() { atlas.remove(ret); }), ret};
}

std::vector<Texture2D> Renderer2D::createTextures(const std::vector<ImageRGBA> &textures) {
    std::map<TextureAtlasResolution, size_t> resolutionCounts;
    for (auto &img: textures) {
        auto res = TextureAtlas::getClosestMatchingResolutionLevel(img.getResolution());
        resolutionCounts[res]++;
    }
    for (auto &pair: resolutionCounts) {
        auto free = atlas.getFreeSlotCount(pair.first);
        if (free < pair.second) {
            auto desc = atlasTextures.at(pair.first)->getDescription();
            desc.textureCount += pair.second - free;
            auto buffer = renderDevice.createTextureArrayBuffer(desc);

            commandBuffer->begin();
            commandBuffer->add(buffer->copy(*atlasTextures.at(pair.first)));
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});

            atlasTextures.at(pair.first) = std::move(buffer);
            auto occupations = atlas.getBufferOccupations();
            occupations[pair.first].resize(desc.textureCount, false);
            atlas = TextureAtlas(occupations);
            updateAtlasRef();
        }
    }
    std::vector<Texture2D> ret;
    ret.reserve(textures.size());
    for (auto &img: textures) {
        auto r = atlas.add(img);
        TextureAtlas::upload(r, atlasRef, img);
        ret.emplace_back(std::make_shared<Texture2D::Deallocator>([this, r]() { atlas.remove(r); }), r);
    }
    return ret;
}

void Renderer2D::renderBegin(RenderTarget &target,
                             bool clear,
                             const ColorRGBA &clearColor,
                             const Vec2i &viewportOffset,
                             const Vec2i &viewportSize,
                             const Vec2f &cameraPosition,
                             const Rectf &projection) {
    if (isRendering) {
        throw std::runtime_error("Already Rendering (Nested Renderer2D::renderBegin calls?)");
    }
    isRendering = true;
    mViewportOffset = viewportOffset;
    mViewportSize = viewportSize;
    mClear = clear;
    mClearColor = clearColor;

    auto prevCam = camera;

    camera.type = ORTHOGRAPHIC;
    camera.left = projection.position.x;
    camera.right = projection.dimensions.x;
    camera.top = projection.position.y;
    camera.bottom = projection.dimensions.y;

    cameraTransform.setPosition({cameraPosition.x, cameraPosition.y, 1});

    if (camera != prevCam ||
        cameraPosition != Vec2f{cameraTransform.getPosition().x, cameraTransform.getPosition().y}) {
        viewProjectionMatrix = camera.projection() * Camera::view(cameraTransform);
    }

    mTarget = &target;
}

void Renderer2D::renderPresent() {
    if (!isRendering) {
        throw std::runtime_error("Not Rendering");
    }
    isRendering = false;

    auto caps = renderDevice.getInfo().capabilities;

    if (caps.find(CAPABILITY_BASE_VERTEX) == caps.end()) {
        throw std::runtime_error("CAPABILITY_BASE_VERTEX is required");
    }

    commandBuffer->begin();
    commandBuffer->add(RenderPass::debugBeginGroup("Renderer 2D Present"));
    commandBuffer->end();
    renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);

    if (mClear) {
        commandBuffer->begin();
        commandBuffer->add(renderPass->begin(*mTarget));
        commandBuffer->add(RenderPass::clearColorAttachments(mClearColor));
        commandBuffer->add(RenderPass::clearDepthAttachment(1));
        commandBuffer->add(RenderPass::end());
        commandBuffer->end();
        renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
    }

    if (caps.find(CAPABILITY_MULTI_DRAW) != caps.end()) {
        presentMultiDraw();
    } else {
        present();
    }

    commandBuffer->begin();
    commandBuffer->add(RenderPass::debugEndGroup());
    commandBuffer->end();
    renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);

    passes.clear();
}

void Renderer2D::draw(const Rectf &srcRect,
                      const Rectf &dstRect,
                      const Texture2D &texture,
                      const Vec2f &center,
                      float rotation,
                      TextureFiltering filter,
                      float mixRGB,
                      float mixAlpha,
                      const ColorRGBA &mixColor) {
    passes.emplace_back(srcRect,
                        dstRect,
                        texture.getHandle(),
                        center,
                        rotation,
                        filter,
                        mixRGB,
                        mixAlpha,
                        mixColor);
}

void Renderer2D::draw(const Rectf &srcRect,
                      const Rectf &dstRect,
                      const Texture2D &texture,
                      const Vec2f &center,
                      float rotation,
                      TextureFiltering filter,
                      ColorRGBA colorFactor) {
    passes.emplace_back(srcRect,
                             dstRect,
                             texture.getHandle(),
                             center,
                             rotation,
                             filter,
                             colorFactor);
}

void Renderer2D::draw(const Rectf &rectangle, const ColorRGBA &color, bool fill, const Vec2f &center, float rotation) {
    passes.emplace_back(rectangle, color, fill, center, rotation);
}

void Renderer2D::draw(const Vec2f &start,
                      const Vec2f &end,
                      const ColorRGBA &color,
                      const Vec2f &position,
                      const Vec2f &center,
                      float rotation) {
    passes.emplace_back(start, end, color, position, center, rotation);
}

void Renderer2D::draw(const Vec2f &point,
                      const ColorRGBA &color,
                      const Vec2f &position,
                      const Vec2f &center,
                      float rotation) {
    passes.emplace_back(point, color, position, center, rotation);
}

void Renderer2D::updateAtlasRef() {
    atlasRef.insert_or_assign(TEXTURE_ATLAS_8x8, *atlasTextures.at(TEXTURE_ATLAS_8x8).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_16x16, *atlasTextures.at(TEXTURE_ATLAS_16x16).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_32x32, *atlasTextures.at(TEXTURE_ATLAS_32x32).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_64x64, *atlasTextures.at(TEXTURE_ATLAS_64x64).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_128x128, *atlasTextures.at(TEXTURE_ATLAS_128x128).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_256x256, *atlasTextures.at(TEXTURE_ATLAS_256x256).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_512x512, *atlasTextures.at(TEXTURE_ATLAS_512x512).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_1024x1024, *atlasTextures.at(TEXTURE_ATLAS_1024x1024).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_2048x2048, *atlasTextures.at(TEXTURE_ATLAS_2048x2048).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_4096x4096, *atlasTextures.at(TEXTURE_ATLAS_4096x4096).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_8192x8192, *atlasTextures.at(TEXTURE_ATLAS_8192x8192).get());
    atlasRef.insert_or_assign(TEXTURE_ATLAS_16384x16384, *atlasTextures.at(TEXTURE_ATLAS_16384x16384).get());
}

void Renderer2D::present() {
    // Separate draws for each mesh

    usedPlanes.clear();
    usedSquares.clear();
    usedLines.clear();
    usedPoints.clear();
    usedRotationMatrices.clear();

    std::vector<DrawCall> drawCalls;
    std::vector<size_t> baseVertices;
    std::vector<Primitive> primitives;
    std::vector<PassData> passData;

    for (auto &pass: passes) {
        switch (pass.type) {
            case Pass::COLOR_POINT: {
                usedPoints.insert(pass.dstRect.position);
                auto point = getPoint(pass.dstRect.position);

                primitives.emplace_back(point.primitive);
                baseVertices.emplace_back(point.baseVertex);
                drawCalls.emplace_back(point.drawCall);

                auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                auto model = MatrixMath::translate({
                                                           pass.srcRect.position.x,
                                                           pass.srcRect.position.y,
                                                           0})
                             * rotMat;

                PassData buffer;

                buffer.mvp = viewProjectionMatrix * model;

                auto color = pass.color.divide();
                buffer.color[0] = color.x;
                buffer.color[1] = color.y;
                buffer.color[2] = color.z;
                buffer.color[3] = color.w;

                passData.emplace_back(buffer);

                break;
            }
            case Pass::COLOR_LINE: {
                usedLines.insert(std::make_pair(pass.dstRect.position, pass.dstRect.dimensions));

                auto line = getLine(pass.dstRect.position, pass.dstRect.dimensions);

                primitives.emplace_back(line.primitive);
                baseVertices.emplace_back(line.baseVertex);
                drawCalls.emplace_back(line.drawCall);

                auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                auto model = MatrixMath::translate({
                                                           pass.srcRect.position.x,
                                                           pass.srcRect.position.y,
                                                           0})
                             * rotMat;

                PassData buffer;

                buffer.mvp = viewProjectionMatrix * model;
                auto color = pass.color.divide();
                buffer.color[0] = color.x;
                buffer.color[1] = color.y;
                buffer.color[2] = color.z;
                buffer.color[3] = color.w;

                passData.emplace_back(buffer);
                break;
            }
            case Pass::COLOR_PLANE: {
                if (pass.fill) {
                    usedPlanes.insert(pass.dstRect.dimensions);
                    auto plane = getPlane(pass.dstRect.dimensions);

                    primitives.emplace_back(plane.primitive);
                    baseVertices.emplace_back(plane.baseVertex);
                    drawCalls.emplace_back(plane.drawCall);
                } else {
                    usedSquares.insert(pass.dstRect.dimensions);
                    auto square = getSquare(pass.dstRect.dimensions);

                    primitives.emplace_back(square.primitive);
                    baseVertices.emplace_back(square.baseVertex);
                    drawCalls.emplace_back(square.drawCall);
                }

                auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                auto model = MatrixMath::translate({
                                                           pass.dstRect.position.x,
                                                           pass.dstRect.position.y,
                                                           0})
                             * rotMat;

                PassData buffer;

                buffer.mvp = viewProjectionMatrix * model;
                auto color = pass.color.divide();
                buffer.color[0] = color.x;
                buffer.color[1] = color.y;
                buffer.color[2] = color.z;
                buffer.color[3] = color.w;

                passData.emplace_back(buffer);
                break;
            }
            case Pass::TEXTURE: {
                usedPlanes.insert(pass.dstRect.dimensions);
                auto plane = getPlane(pass.dstRect.dimensions);

                primitives.emplace_back(plane.primitive);
                baseVertices.emplace_back(plane.baseVertex);
                drawCalls.emplace_back(plane.drawCall);

                auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                auto model = MatrixMath::translate({
                                                           pass.dstRect.position.x,
                                                           pass.dstRect.position.y,
                                                           0})
                             * rotMat;

                PassData buffer;

                buffer.mvp = viewProjectionMatrix * model;

                auto color = pass.color.divide();
                buffer.color[0] = color.x;
                buffer.color[1] = color.y;
                buffer.color[2] = color.z;
                buffer.color[3] = color.w;

                buffer.colorMixFactor = pass.mix;
                buffer.alphaMixFactor = pass.alphaMix;
                buffer.colorFactor = pass.colorFactor;
                buffer.texAtlasLevel = pass.texture.level;
                buffer.texAtlasIndex = (int) pass.texture.index;
                buffer.texFilter = pass.filter == LINEAR ? 1 : 0;
                auto uvOffset = pass.srcRect.position / pass.texture.size.convert<float>();
                buffer.uvOffset_uvScale[0] = uvOffset.x;
                buffer.uvOffset_uvScale[1] = uvOffset.y;
                auto uvScale = (pass.srcRect.dimensions /
                                pass.texture.size.convert<float>());
                buffer.uvOffset_uvScale[2] = uvScale.x;
                buffer.uvOffset_uvScale[3] = uvScale.y;
                auto atlasScale = (pass.texture.size.convert<float>() /
                                   TextureAtlas::getResolutionLevelSize(
                                           pass.texture.level).convert<float>());
                buffer.atlasScale_texSize[0] = atlasScale.x;
                buffer.atlasScale_texSize[1] = atlasScale.y;
                buffer.atlasScale_texSize[2] = static_cast<float>(pass.texture.size.x);
                buffer.atlasScale_texSize[3] = static_cast<float>(pass.texture.size.y);

                passData.emplace_back(buffer);

                break;
            }
        }
    }

    std::unordered_set<Vec2f> unusedPlanes;
    std::unordered_set<Vec2f> unusedSquares;
    std::unordered_set<std::pair<Vec2f, Vec2f>, LinePairHash> unusedLines;
    std::unordered_set<Vec2f> unusedPoints;
    std::unordered_set<std::pair<float, Vec2f>, RotationPairHash> unusedRotationMatrices;

    for (auto &pair: planeMeshes) {
        if (usedPlanes.find(pair.first) == usedPlanes.end()) {
            unusedPlanes.insert(pair.first);
        }
    }

    for (auto &pair: squareMeshes) {
        if (usedSquares.find(pair.first) == usedSquares.end()) {
            unusedSquares.insert(pair.first);
        }
    }

    for (auto &pair: lineMeshes) {
        if (usedLines.find(pair.first) == usedLines.end()) {
            unusedLines.insert(pair.first);
        }
    }

    for (auto &pair: pointMeshes) {
        if (usedPoints.find(pair.first) == usedPoints.end()) {
            unusedPoints.insert(pair.first);
        }
    }

    for (auto &pair: rotationMatrices) {
        if (usedRotationMatrices.find(pair.first) == usedRotationMatrices.end()) {
            unusedRotationMatrices.insert(pair.first);
        }
    }

    for (auto &v: unusedPlanes) {
        destroyPlane(v);
    }

    for (auto &v: unusedSquares) {
        destroySquare(v);
    }

    for (auto &v: unusedLines) {
        destroyLine(v.first, v.second);
    }

    for (auto &v: unusedPoints) {
        destroyPoint(v);
    }

    for (auto &v: unusedRotationMatrices) {
        rotationMatrices.erase(v);
    }

    mergeFreeVertexBufferRanges();
    mergeFreeIndexBufferRanges();

    updateVertexArrayObject();

    std::vector<std::unique_ptr<ShaderUniformBuffer>> shaderBuffers;
    shaderBuffers.reserve(drawCalls.size());

    std::vector<DrawBatch> batches;
    DrawBatch currentBatch;
    for (auto y = 0; y < drawCalls.size(); y++) {
        auto prim = primitives.at(y);
        if (prim != currentBatch.primitive) {
            if (!currentBatch.drawCalls.empty())
                batches.emplace_back(currentBatch);
            currentBatch = {};
            currentBatch.primitive = prim;
        }
        currentBatch.drawCalls.emplace_back(drawCalls.at(y));
        currentBatch.baseVertices.emplace_back(baseVertices.at(y));
        currentBatch.uniformBuffers.emplace_back(passData.at(y));

        ShaderUniformBufferDesc shaderBufferDesc;
        shaderBufferDesc.size = sizeof(PassData);
        shaderBuffers.emplace_back(renderDevice.createShaderUniformBuffer(shaderBufferDesc));
        shaderBuffers.at(shaderBuffers.size() - 1)->upload(passData.at(y));
    }
    if (!currentBatch.drawCalls.empty())
        batches.emplace_back(currentBatch);

    auto drawCallIndex = 0;
    for (auto &batch: batches) {
        std::vector<Command> commands;

        commands.emplace_back(renderPass->begin(*mTarget));
        commands.emplace_back(RenderPass::setViewport(mViewportOffset, mViewportSize));

        switch (batch.primitive) {
            case POINTS:
                commands.emplace_back(pointPipeline->bind());
                break;
            case LINES:
                commands.emplace_back(linePipeline->bind());
                break;
            case TRIANGLES:
                commands.emplace_back(trianglePipeline->bind());
                break;
            default:
                throw std::runtime_error("Unsupported primitive");
        }

        commands.emplace_back(vertexArrayObject->bind());

        for (auto y = 0; y < batch.drawCalls.size(); y++) {
            auto resources = std::vector<ShaderResource>{
                    {*shaderBuffers.at(
                            drawCallIndex++),                      {{VERTEX, ShaderResource::READ}, {FRAGMENT, ShaderResource::READ}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_8x8),         {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_16x16),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_32x32),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_64x64),       {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_128x128),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_256x256),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_512x512),     {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_1024x1024),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_2048x2048),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_4096x4096),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_8192x8192),   {{{FRAGMENT, ShaderResource::READ}}}},
                    {*atlasTextures.at(TEXTURE_ATLAS_16384x16384), {{{FRAGMENT, ShaderResource::READ}}}},
            };

            commands.emplace_back(RenderPipeline::bindShaderResources(resources));
            commands.emplace_back(RenderPass::drawIndexed(batch.drawCalls.at(y), batch.baseVertices.at(y)));
        }

        commands.emplace_back(RenderPass::end());

        commandBuffer->begin();
        commandBuffer->add(commands);
        commandBuffer->end();

        renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
    }
}

void Renderer2D::presentMultiDraw() {
    // Multi Draw accelerated draw path

    size_t totalBufferSize = passes.size() * sizeof(PassData);
    size_t maxBufferSize = renderDevice.getInfo().storageBufferMaxSize;

    size_t drawCycles = 0;
    if (totalBufferSize > maxBufferSize) {
        drawCycles = totalBufferSize / maxBufferSize;
        auto remainder = totalBufferSize % maxBufferSize;
        if (remainder > 0) {
            drawCycles += 1;
        }
    } else if (!passes.empty()) {
        drawCycles = 1;
    }

    size_t numberOfPassesPerCycle = maxBufferSize / sizeof(PassData);

    for (int i = 0; i < drawCycles; i++) {
        usedPlanes.clear();
        usedSquares.clear();
        usedLines.clear();
        usedPoints.clear();
        usedRotationMatrices.clear();

        std::vector<DrawCall> drawCalls;
        std::vector<size_t> baseVertices;
        std::vector<Primitive> primitives;
        std::vector<PassData> passData;

        auto currentPassBase = i * numberOfPassesPerCycle;
        for (auto passIndex = 0;
             passIndex < numberOfPassesPerCycle && passIndex + currentPassBase < passes.size();
             passIndex++) {
            auto &pass = passes.at(passIndex + currentPassBase);
            PassData data;
            switch (pass.type) {
                case Pass::COLOR_POINT: {
                    usedPoints.insert(pass.dstRect.position);
                    auto point = getPoint(pass.dstRect.position);

                    primitives.emplace_back(point.primitive);
                    baseVertices.emplace_back(point.baseVertex);
                    drawCalls.emplace_back(point.drawCall);


                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.srcRect.position.x,
                                                               pass.srcRect.position.y,
                                                               0})
                                 * rotMat;

                    data.mvp = viewProjectionMatrix * model;
                    auto color = pass.color.divide();
                    data.color[0] = color.x;
                    data.color[1] = color.y;
                    data.color[2] = color.z;
                    data.color[3] = color.w;
                    break;
                }
                case Pass::COLOR_LINE: {
                    usedLines.insert(std::make_pair(pass.dstRect.position, pass.dstRect.dimensions));

                    auto line = getLine(pass.dstRect.position, pass.dstRect.dimensions);

                    primitives.emplace_back(line.primitive);
                    baseVertices.emplace_back(line.baseVertex);
                    drawCalls.emplace_back(line.drawCall);


                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.srcRect.position.x,
                                                               pass.srcRect.position.y,
                                                               0})
                                 * rotMat;

                    data.mvp = viewProjectionMatrix * model;
                    auto color = pass.color.divide();
                    data.color[0] = color.x;
                    data.color[1] = color.y;
                    data.color[2] = color.z;
                    data.color[3] = color.w;
                    break;
                }
                case Pass::COLOR_PLANE: {
                    if (pass.fill) {
                        usedPlanes.insert(pass.dstRect.dimensions);
                        auto plane = getPlane(pass.dstRect.dimensions);

                        primitives.emplace_back(plane.primitive);
                        baseVertices.emplace_back(plane.baseVertex);
                        drawCalls.emplace_back(plane.drawCall);
                    } else {
                        usedSquares.insert(pass.dstRect.dimensions);
                        auto square = getSquare(pass.dstRect.dimensions);

                        primitives.emplace_back(square.primitive);
                        baseVertices.emplace_back(square.baseVertex);
                        drawCalls.emplace_back(square.drawCall);
                    }

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.dstRect.position.x,
                                                               pass.dstRect.position.y,
                                                               0})
                                 * rotMat;

                    data.mvp = viewProjectionMatrix * model;
                    auto color = pass.color.divide();
                    data.color[0] = color.x;
                    data.color[1] = color.y;
                    data.color[2] = color.z;
                    data.color[3] = color.w;
                    break;
                }
                case Pass::TEXTURE: {
                    usedPlanes.insert(pass.dstRect.dimensions);
                    auto plane = getPlane(pass.dstRect.dimensions);

                    primitives.emplace_back(plane.primitive);
                    baseVertices.emplace_back(plane.baseVertex);
                    drawCalls.emplace_back(plane.drawCall);

                    auto rotMat = getRotationMatrix(pass.rotation, pass.center);

                    auto model = MatrixMath::translate({
                                                               pass.dstRect.position.x,
                                                               pass.dstRect.position.y,
                                                               0})
                                 * rotMat;

                    data.mvp = viewProjectionMatrix * model;

                    auto color = pass.color.divide();
                    data.color[0] = color.x;
                    data.color[1] = color.y;
                    data.color[2] = color.z;
                    data.color[3] = color.w;
                    data.colorMixFactor = pass.mix;
                    data.alphaMixFactor = pass.alphaMix;
                    data.colorFactor = pass.colorFactor;
                    data.texAtlasLevel = pass.texture.level;
                    data.texAtlasIndex = (int) pass.texture.index;
                    data.texFilter = pass.filter == LINEAR ? 1 : 0;
                    auto uvOffset = pass.srcRect.position / pass.texture.size.convert<float>();
                    data.uvOffset_uvScale[0] = uvOffset.x;
                    data.uvOffset_uvScale[1] = uvOffset.y;
                    auto uvScale = (pass.srcRect.dimensions /
                                    pass.texture.size.convert<float>());
                    data.uvOffset_uvScale[2] = uvScale.x;
                    data.uvOffset_uvScale[3] = uvScale.y;
                    auto atlasScale = (pass.texture.size.convert<float>() /
                                       TextureAtlas::getResolutionLevelSize(
                                               pass.texture.level).convert<float>());
                    data.atlasScale_texSize[0] = atlasScale.x;
                    data.atlasScale_texSize[1] = atlasScale.y;
                    data.atlasScale_texSize[2] = static_cast<float>(pass.texture.size.x);
                    data.atlasScale_texSize[3] = static_cast<float>(pass.texture.size.y);
                    break;
                }
            }
            passData.emplace_back(data);
        }

        std::unordered_set<Vec2f> unusedPlanes;
        std::unordered_set<Vec2f> unusedSquares;
        std::unordered_set<std::pair<Vec2f, Vec2f>, LinePairHash> unusedLines;
        std::unordered_set<Vec2f> unusedPoints;
        std::unordered_set<std::pair<float, Vec2f>, RotationPairHash> unusedRotationMatrices;

        for (auto &pair: planeMeshes) {
            if (usedPlanes.find(pair.first) == usedPlanes.end()) {
                unusedPlanes.insert(pair.first);
            }
        }

        for (auto &pair: squareMeshes) {
            if (usedSquares.find(pair.first) == usedSquares.end()) {
                unusedSquares.insert(pair.first);
            }
        }

        for (auto &pair: lineMeshes) {
            if (usedLines.find(pair.first) == usedLines.end()) {
                unusedLines.insert(pair.first);
            }
        }

        for (auto &pair: pointMeshes) {
            if (usedPoints.find(pair.first) == usedPoints.end()) {
                unusedPoints.insert(pair.first);
            }
        }

        for (auto &pair: rotationMatrices) {
            if (usedRotationMatrices.find(pair.first) == usedRotationMatrices.end()) {
                unusedRotationMatrices.insert(pair.first);
            }
        }

        for (auto &v: unusedPlanes) {
            destroyPlane(v);
        }

        for (auto &v: unusedSquares) {
            destroySquare(v);
        }

        for (auto &v: unusedLines) {
            destroyLine(v.first, v.second);
        }

        for (auto &v: unusedPoints) {
            destroyPoint(v);
        }

        for (auto &v: unusedRotationMatrices) {
            rotationMatrices.erase(v);
        }

        mergeFreeVertexBufferRanges();
        mergeFreeIndexBufferRanges();

        updateVertexArrayObject();

        std::vector<DrawBatch> batches;
        DrawBatch currentBatch;

        for (auto y = 0; y < drawCalls.size(); y++) {
            auto prim = primitives.at(y);
            if (prim != currentBatch.primitive) {
                if (!currentBatch.drawCalls.empty())
                    batches.emplace_back(currentBatch);
                currentBatch = {};
                currentBatch.primitive = prim;
            }
            currentBatch.drawCalls.emplace_back(drawCalls.at(y));
            currentBatch.baseVertices.emplace_back(baseVertices.at(y));
            currentBatch.uniformBuffers.emplace_back(passData.at(y));
        }

        if (!currentBatch.drawCalls.empty())
            batches.emplace_back(currentBatch);

        auto bufSize = sizeof(PassData) * numberOfPassesPerCycle;
        if (bufSize > totalBufferSize)
            bufSize = totalBufferSize;

        ShaderStorageBufferDesc shaderBufferDesc;
        shaderBufferDesc.size = bufSize;
        auto shaderBuffer = renderDevice.createShaderStorageBuffer(shaderBufferDesc);

        auto resources = std::vector<ShaderResource>{
                {*shaderBuffer,                                {{VERTEX, ShaderResource::READ}, {FRAGMENT, ShaderResource::READ}}},
                {*atlasTextures.at(TEXTURE_ATLAS_8x8),         {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_16x16),       {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_32x32),       {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_64x64),       {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_128x128),     {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_256x256),     {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_512x512),     {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_1024x1024),   {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_2048x2048),   {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_4096x4096),   {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_8192x8192),   {{{FRAGMENT, ShaderResource::READ}}}},
                {*atlasTextures.at(TEXTURE_ATLAS_16384x16384), {{{FRAGMENT, ShaderResource::READ}}}},
        };

        for (auto &batch: batches) {
            shaderBuffer->upload(0, reinterpret_cast<const uint8_t *>(batch.uniformBuffers.data()),
                                 batch.uniformBuffers.size() * sizeof(PassData));

            std::vector<Command> commands;

            commands.emplace_back(renderPass->begin(*mTarget));
            commands.emplace_back(RenderPass::setViewport(mViewportOffset, mViewportSize));

            commands.emplace_back(vertexArrayObject->bind());

            switch (batch.primitive) {
                case POINTS:
                    commands.emplace_back(pointPipelineMultiDraw->bind());
                    break;
                case LINES:
                    commands.emplace_back(linePipelineMultiDraw->bind());
                    break;
                case TRIANGLES:
                    commands.emplace_back(trianglePipelineMultiDraw->bind());
                    break;
                default:
                    throw std::runtime_error("Unsupported primitive");
            }

            commands.emplace_back(RenderPipeline::bindShaderResources(resources));
            commands.emplace_back(RenderPass::multiDrawIndexed(batch.drawCalls, batch.baseVertices));
            commands.emplace_back(RenderPass::end());
            commandBuffer->begin();
            commandBuffer->add(commands);
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit({*commandBuffer}, {}, {});
        }
    }
}

Renderer2D::MeshDrawData Renderer2D::getPlane(const Vec2f &size) {
    auto it = planeMeshes.find(size);
    if (it != planeMeshes.end()) {
        return it->second;
    } else {
        VertexStream vertexStream;

        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(0, 0))
                                       .addVec2(Vec2f(0, 0))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(size.x, 0))
                                       .addVec2(Vec2f(1, 0))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(0, size.y))
                                       .addVec2(Vec2f(0, 1))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(size.x,
                                                      size.y))
                                       .addVec2(Vec2f(1, 1))
                                       .build());

        auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

        vertexBuffer->upload(vertexBufferOffset,
                             vertexStream.getVertexBuffer().data(),
                             vertexStream.getVertexBuffer().size());

        std::vector<unsigned int> indices;
        indices.emplace_back(0);
        indices.emplace_back(1);
        indices.emplace_back(2);

        indices.emplace_back(1);
        indices.emplace_back(2);
        indices.emplace_back(3);

        auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

        auto drawCall = DrawCall(indexBufferOffset, indices.size());

        indexBuffer->upload(indexBufferOffset,
                            reinterpret_cast<const uint8_t *>(indices.data()),
                            indices.size() * sizeof(unsigned int));

        planeMeshes[size] = MeshDrawData(TRIANGLES,
                drawCall,
                vertexBufferOffset / vertexLayout.getSize());

        return planeMeshes.at(size);
    }
}

Renderer2D::MeshDrawData Renderer2D::getSquare(const Vec2f &size) {
    auto it = squareMeshes.find(size);
    if (it != squareMeshes.end()) {
        return it->second;
    } else {
        VertexStream vertexStream;

        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(0, 0))
                                       .addVec2(Vec2f(0, 0))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(size.x, 0))
                                       .addVec2(Vec2f(1, 0))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(0, size.y))
                                       .addVec2(Vec2f(0, 1))
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(Vec2f(size.x,
                                                      size.y))
                                       .addVec2(Vec2f(1, 1))
                                       .build());

        auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

        vertexBuffer->upload(vertexBufferOffset,
                             vertexStream.getVertexBuffer().data(),
                             vertexStream.getVertexBuffer().size());

        std::vector<unsigned int> indices;
        indices.emplace_back(0);
        indices.emplace_back(1);

        indices.emplace_back(1);
        indices.emplace_back(3);

        indices.emplace_back(3);
        indices.emplace_back(2);

        indices.emplace_back(2);
        indices.emplace_back(0);

        auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

        auto drawCall = DrawCall(indexBufferOffset, indices.size());

        indexBuffer->upload(indexBufferOffset,
                            reinterpret_cast<const uint8_t *>(indices.data()),
                            indices.size() * sizeof(unsigned int));

        squareMeshes[size] = MeshDrawData(LINES,
                drawCall,
                vertexBufferOffset / vertexLayout.getSize());

        return squareMeshes.at(size);
    }

}

Renderer2D::MeshDrawData Renderer2D::getLine(const Vec2f &start, const Vec2f &end) {
    auto pair = std::make_pair(start, end);
    auto it = lineMeshes.find(pair);
    if (it != lineMeshes.end()) {
        return it->second;
    } else {
        VertexStream vertexStream;

        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(start)
                                       .addVec2(Vec2f())
                                       .build());
        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(end)
                                       .addVec2(Vec2f())
                                       .build());

        auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

        vertexBuffer->upload(vertexBufferOffset,
                             vertexStream.getVertexBuffer().data(),
                             vertexStream.getVertexBuffer().size());

        std::vector<unsigned int> indices;
        indices.emplace_back(0);
        indices.emplace_back(1);

        auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

        auto drawCall = DrawCall(indexBufferOffset, indices.size());

        indexBuffer->upload(indexBufferOffset,
                            reinterpret_cast<const uint8_t *>(indices.data()),
                            indices.size() * sizeof(unsigned int));

        lineMeshes[pair] = MeshDrawData(LINES,
                drawCall,
                vertexBufferOffset / vertexLayout.getSize());

        return lineMeshes.at(pair);
    }
}

Renderer2D::MeshDrawData Renderer2D::getPoint(const Vec2f &point) {
    auto it = pointMeshes.find(point);
    if (it != pointMeshes.end()) {
        return it->second;
    } else {
        VertexStream vertexStream;

        vertexStream.addVertex(VertexBuilder()
                                       .addVec2(point)
                                       .addVec2(Vec2f())
                                       .build());

        auto vertexBufferOffset = allocateVertexData(vertexStream.getVertexBuffer().size());

        vertexBuffer->upload(vertexBufferOffset,
                             vertexStream.getVertexBuffer().data(),
                             vertexStream.getVertexBuffer().size());

        std::vector<unsigned int> indices;
        indices.emplace_back(0);

        auto indexBufferOffset = allocateIndexData(indices.size() * sizeof(unsigned int));

        auto drawCall = DrawCall(indexBufferOffset, indices.size());

        indexBuffer->upload(indexBufferOffset,
                            reinterpret_cast<const uint8_t *>(indices.data()),
                            indices.size() * sizeof(unsigned int));

        pointMeshes[point] = MeshDrawData(POINTS,
                drawCall,
                vertexBufferOffset / vertexLayout.getSize());

        return pointMeshes.at(point);
    }
}

void Renderer2D::destroyPlane(const Vec2f &size) {
    auto drawData = planeMeshes.at(size);
    planeMeshes.erase(size);
    deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
    deallocateIndexData(drawData.drawCall.offset);
}

void Renderer2D::destroySquare(const Vec2f &size) {
    auto drawData = squareMeshes.at(size);
    squareMeshes.erase(size);
    deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
    deallocateIndexData(drawData.drawCall.offset);
}

void Renderer2D::destroyLine(const Vec2f &start, const Vec2f &end) {
    auto pair = std::make_pair(start, end);
    auto drawData = lineMeshes.at(pair);
    lineMeshes.erase(pair);
    deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
    deallocateIndexData(drawData.drawCall.offset);
}

void Renderer2D::destroyPoint(const Vec2f &point) {
    auto drawData = pointMeshes.at(point);
    pointMeshes.erase(point);
    deallocateVertexData(drawData.baseVertex * vertexLayout.getSize());
    deallocateIndexData(drawData.drawCall.offset);
}

size_t Renderer2D::allocateVertexData(size_t size) {
    bool foundFreeRange = false;
    auto ret = 0UL;
    for (auto &range: freeVertexBufferRanges) {
        if (range.second >= size) {
            ret = range.first;
            foundFreeRange = true;
        }
    }

    if (foundFreeRange) {
        auto rangeSize = freeVertexBufferRanges.at(ret) -= size;
        freeVertexBufferRanges.erase(ret);
        if (rangeSize > 0) {
            freeVertexBufferRanges[ret + size] = rangeSize;
        }
    } else {
        ret = vertexBuffer->getDescription().size;
    }

    if (vertexBuffer->getDescription().size <= ret
        || vertexBuffer->getDescription().size < ret + size) {
        VertexBufferDesc desc;
        desc.size = vertexBuffer->getDescription().size + size;
        auto nBuffer = renderDevice.createVertexBuffer(desc);
        if (vertexBuffer->getDescription().size > 0) {
            commandBuffer->begin();
            commandBuffer->add(nBuffer->copy(*vertexBuffer));
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
        }
        vertexBuffer = std::move(nBuffer);
        vaoChange = true;
    }

    allocatedVertexRanges[ret] = size;

    return ret;
}

void Renderer2D::deallocateVertexData(size_t offset) {
    auto size = allocatedVertexRanges.at(offset);
    allocatedVertexRanges.erase(offset);
    freeVertexBufferRanges[offset] = size;
}

size_t Renderer2D::allocateIndexData(size_t size) {
    bool foundFreeRange = false;
    auto ret = 0UL;
    for (auto &range: freeIndexBufferRanges) {
        if (range.second >= size) {
            ret = range.first;
            foundFreeRange = true;
        }
    }
    if (foundFreeRange) {
        auto rangeSize = freeIndexBufferRanges.at(ret) -= size;
        freeIndexBufferRanges.erase(ret);
        if (rangeSize > 0) {
            freeIndexBufferRanges[ret + size] = rangeSize;
        }
    } else {
        ret = indexBuffer->getDescription().size;
    }

    if (indexBuffer->getDescription().size <= ret
        || indexBuffer->getDescription().size <= ret + size) {
        IndexBufferDesc desc;
        desc.size = indexBuffer->getDescription().size + size;
        auto nBuffer = renderDevice.createIndexBuffer(desc);
        if (indexBuffer->getDescription().size > 0) {
            commandBuffer->begin();
            commandBuffer->add(nBuffer->copy(*indexBuffer));
            commandBuffer->end();
            renderDevice.getRenderCommandQueues().at(0).get().submit(*commandBuffer);
        }
        indexBuffer = std::move(nBuffer);
        vaoChange = true;
    }

    allocatedIndexRanges[ret] = size;

    return ret;
}

void Renderer2D::deallocateIndexData(size_t offset) {
    auto size = allocatedIndexRanges.at(offset);
    allocatedIndexRanges.erase(offset);
    freeIndexBufferRanges[offset] = size;
}

void Renderer2D::mergeFreeVertexBufferRanges() {
    bool merged = true;
    while (merged) {
        merged = false;
        auto vertexRanges = freeVertexBufferRanges;
        for (auto range = freeVertexBufferRanges.begin(); range != freeVertexBufferRanges.end(); range++) {
            auto next = range;
            next++;
            if (next != freeVertexBufferRanges.end()) {
                if (range->first + range->second == next->first
                    && vertexRanges.find(range->first) != vertexRanges.end()
                    && vertexRanges.find(next->first) != vertexRanges.end()) {
                    merged = true;
                    vertexRanges.at(range->first) += next->second;
                    vertexRanges.erase(next->first);
                    range = next;
                }
            }
        }
        freeVertexBufferRanges = vertexRanges;
    }
}

void Renderer2D::mergeFreeIndexBufferRanges() {
    bool merged = true;
    while (merged) {
        merged = false;
        auto indexRanges = freeIndexBufferRanges;
        for (auto range = freeIndexBufferRanges.begin(); range != freeIndexBufferRanges.end(); range++) {
            auto next = range;
            next++;
            if (next != freeIndexBufferRanges.end()) {
                if (range->first + range->second == next->first
                    && indexRanges.find(range->first) != indexRanges.end()
                    && indexRanges.find(next->first) != indexRanges.end()) {
                    merged = true;
                    indexRanges.at(range->first) += next->second;
                    indexRanges.erase(next->first);
                    range = next;
                }
            }
        }
        freeIndexBufferRanges = indexRanges;
    }
}

void Renderer2D::updateVertexArrayObject() {
    if (vaoChange) {
        vaoChange = false;
        vertexArrayObject->setBuffers(*vertexBuffer, *indexBuffer);
    }
}

Mat4f Renderer2D::getRotationMatrix(float rotation, Vec2f center) {
    auto pair = std::make_pair(rotation, center);
    usedRotationMatrices.insert(pair);
    auto it = rotationMatrices.find(pair);
    if (it != rotationMatrices.end()) {
        return it->second;
    } else {
        rotationMatrices[pair] = MatrixMath::translate({
                                                               center.x,
                                                               center.y,
                                                               0})
                                 * MatrixMath::rotate(Vec3f(0, 0, rotation))
                                 * MatrixMath::translate({
                                                                 -center.x,
                                                                 -center.y,
                                                                 0});
        return rotationMatrices.at(pair);
    }
}
}**/
